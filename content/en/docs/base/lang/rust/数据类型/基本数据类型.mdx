---
title: åŸºæœ¬æ•°æ®ç±»å‹
sidebar_position: 1
slug: åŸºæœ¬æ•°æ®ç±»å‹
---

æ•°å­—æ–‡å­—å¯ä»¥é€šè¿‡æ·»åŠ ç±»å‹ä½œä¸ºåç¼€æ¥è¿›è¡Œç±»å‹æ³¨é‡Šã€‚ä¾‹å¦‚ï¼Œè¦æŒ‡å®šæ–‡å­— 42 çš„ç±»å‹åº”ä¸º i32 ï¼Œè¯·ç¼–å†™ 42i32 ã€‚

æ— åç¼€æ•°å­—æ–‡å­—çš„ç±»å‹å–å†³äºå®ƒä»¬çš„ä½¿ç”¨æ–¹å¼ã€‚å¦‚æœä¸å­˜åœ¨çº¦æŸï¼Œç¼–è¯‘å™¨å°†ä½¿ç”¨ i32 è¡¨ç¤ºæ•´æ•°ï¼Œä½¿ç”¨ f64 è¡¨ç¤ºæµ®ç‚¹æ•°ã€‚

å‰é¢çš„ä»£ç ä¸­ç”¨åˆ°äº†ä¸€äº›æ¦‚å¿µè¿˜æ²¡æœ‰è§£é‡Šï¼Œè¿™é‡Œç»™ä¸è€çƒ¦çš„è¯»è€…åšä¸€ä¸ªç®€å•çš„è§£é‡Šï¼š

std::mem::size_of_val æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä½†ä½¿ç”¨å…¶å®Œæ•´è·¯å¾„è¿›è¡Œè°ƒç”¨ã€‚ä»£ç å¯ä»¥åˆ†å‰²æˆç§°ä¸ºæ¨¡å—çš„é€»è¾‘å•å…ƒã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œ size_of_val å‡½æ•°åœ¨ mem æ¨¡å—ä¸­å®šä¹‰ï¼Œ mem æ¨¡å—åœ¨ std åŒ…ä¸­å®šä¹‰ã€‚æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æ¨¡å—å’Œ crateã€‚

```rust
fn main() {
    // Suffixed literals, their types are known at initialization
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // Unsuffixed literals, their types depend on how they are used
    let i = 1;
    let f = 1.0;

    // `size_of_val` returns the size of a variable in bytes
    println!("size of `x` in bytes: {}", std::mem::size_of_val(&x));
    println!("size of `y` in bytes: {}", std::mem::size_of_val(&y));
    println!("size of `z` in bytes: {}", std::mem::size_of_val(&z));
    println!("size of `i` in bytes: {}", std::mem::size_of_val(&i));
    println!("size of `f` in bytes: {}", std::mem::size_of_val(&f));
}
```

## æ•´å‹

rust æ ‡é‡ç±»å‹éƒ½æ˜¯é€šè¿‡è‡ªåŠ¨æ‹·è´çš„æ–¹å¼æ¥èµ‹å€¼çš„ã€‚

### æ•´æ•°int

```rust
fn main() {
    let x:i32 = -32;
    let y:u32 = 45;
    let z:i64 = -3332;
    let t:isize = 43;//å¤§å°ä¸è®¡ç®—æœºæ¶æ„ç›¸åŒ
    let r:usize = 143;//å¤§å°ä¸è®¡ç®—æœºæ¶æ„ç›¸åŒ
    //æ•´å½¢å­—é¢å€¼
    let a = 0xff;
    let b = 98_22;
    let c = 0b1111_0000;
    let d = b'A';//è¡¨ç¤ºchar Açš„Unicodeç¼–ç  è¾“å‡ºç”¨decimalè¡¨ç¤º
}

```

### å¸ƒå°”bool

æ­£å¦‚å…¶ä»–å¤§éƒ¨åˆ†ç¼–ç¨‹è¯­è¨€ä¸€æ ·ï¼Œrust ä¸­çš„å¸ƒå°”ç±»å‹æœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼ï¼š`true` å’Œ `false`ã€‚rust ä¸­çš„å¸ƒå°”ç±»å‹ä½¿ç”¨ `bool` è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼š

```rust
fn main() {
    let t = true;

    let f: bool = false; // æ˜¾å¼æŒ‡å®šç±»å‹æ³¨è§£
}
```

### æµ®ç‚¹float

```rust
fn main() {
    let x = 2.0; // f64 åŒç²¾åº¦

    let y: f32 = 3.0; // f32 å•ç²¾åº¦
}
```

### å­—ç¬¦char

ç›®å‰ä¸ºæ­¢åªä½¿ç”¨åˆ°äº†æ•°å­—ï¼Œä¸è¿‡ rust ä¹Ÿæ”¯æŒå­—æ¯ã€‚rust çš„ `char` ç±»å‹æ˜¯è¯­è¨€ä¸­æœ€åŸç”Ÿçš„å­—æ¯ç±»å‹ï¼Œå¦‚ä¸‹ä»£ç å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨å®ƒã€‚ï¼ˆæ³¨æ„ `char` ç”±å•å¼•å·æŒ‡å®šï¼Œä¸åŒäºå­—ç¬¦ä¸²ä½¿ç”¨åŒå¼•å·ã€‚ï¼‰

```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
```

rust çš„ `char` ç±»å‹çš„å¤§å°ä¸ºå››ä¸ªå­—èŠ‚(four bytes)ï¼Œå¹¶ä»£è¡¨äº†ä¸€ä¸ª Unicode æ ‡é‡å€¼ï¼ˆUnicode Scalar Valueï¼‰ï¼Œè¿™æ„å‘³ç€å®ƒå¯ä»¥æ¯” ASCII è¡¨ç¤ºæ›´å¤šå†…å®¹ã€‚åœ¨ rust ä¸­ï¼Œæ‹¼éŸ³å­—æ¯ï¼ˆAccented lettersï¼‰ï¼Œä¸­æ–‡ã€æ—¥æ–‡ã€éŸ©æ–‡ç­‰å­—ç¬¦ï¼Œemojiï¼ˆç»˜æ–‡å­—ï¼‰ä»¥åŠé›¶é•¿åº¦çš„ç©ºç™½å­—ç¬¦éƒ½æ˜¯æœ‰æ•ˆçš„ `char` å€¼ã€‚Unicode æ ‡é‡å€¼åŒ…å«ä» `U+0000` åˆ° `U+D7FF` å’Œ `U+E000` åˆ° `U+10FFFF` åœ¨å†…çš„å€¼ã€‚ä¸è¿‡ï¼Œâ€œå­—ç¬¦â€ å¹¶ä¸æ˜¯ä¸€ä¸ª Unicode ä¸­çš„æ¦‚å¿µï¼Œæ‰€ä»¥äººç›´è§‰ä¸Šçš„ â€œå­—ç¬¦â€ å¯èƒ½ä¸ rust ä¸­çš„ `char` å¹¶ä¸ç¬¦åˆã€‚

### &T

æ¯”å¦‚&strï¼Œ&[T]ç­‰

## ç±»å‹è½¬æ¢

rust æä¾›äº†å¤šç§æœºåˆ¶æ¥æ›´æ”¹æˆ–å®šä¹‰åŸå§‹ç±»å‹å’Œç”¨æˆ·å®šä¹‰ç±»å‹ã€‚ä»¥ä¸‹éƒ¨åˆ†æ¶µç›–ï¼š

- åŸå§‹ç±»å‹ä¹‹é—´çš„è½¬æ¢
- æŒ‡å®šæ‰€éœ€çš„æ–‡å­—ç±»å‹
- ä½¿ç”¨ç±»å‹æ¨æ–­
- åˆ«åç±»å‹

rust ä¸æä¾›åŸå§‹ç±»å‹ä¹‹é—´çš„éšå¼ç±»å‹è½¬æ¢ï¼ˆå¼ºåˆ¶ï¼‰ã€‚ä½†æ˜¯ï¼Œå¯ä»¥ä½¿ç”¨ as å…³é”®å­—æ‰§è¡Œæ˜¾å¼ç±»å‹è½¬æ¢ï¼ˆå¼ºåˆ¶è½¬æ¢ï¼‰ã€‚

æ•´æ•°ç±»å‹ä¹‹é—´çš„è½¬æ¢è§„åˆ™é€šå¸¸éµå¾ª C çº¦å®šï¼Œé™¤é C å…·æœ‰æœªå®šä¹‰çš„è¡Œä¸ºã€‚ rust ä¸­æ˜ç¡®å®šä¹‰äº†æ•´å‹ç±»å‹ä¹‹é—´æ‰€æœ‰å¼ºåˆ¶è½¬æ¢çš„è¡Œä¸ºã€‚

```rust
// Suppress all warnings from casts which overflow.
#![allow(overflowing_literals)]

fn main() {
  let decimal = 65.4321_f32;

  // Error! No implicit conversion
  let integer: u8 = decimal;
  // FIXME ^ Comment out this line

  // Explicit conversion
  let integer = decimal as u8;
  let character = integer as char;

  // Error! There are limitations in conversion rules.
  // A float cannot be directly converted to a char.
  let character = decimal as char;
  // FIXME ^ Comment out this line

  println!("Casting: {} -> {} -> {}", decimal, integer, character);

  // when casting any value to an unsigned type, T,
  // T::MAX + 1 is added or subtracted until the value
  // fits into the new type

  // 1000 already fits in a u16
  println!("1000 as a u16 is: {}", 1000 as u16);

  // 1000 - 256 - 256 - 256 = 232
  // Under the hood, the first 8 least significant bits (LSB) are kept,
  // while the rest towards the most significant bit (MSB) get truncated.
  println!("1000 as a u8 is : {}", 1000 as u8);
  // -1 + 256 = 255
  println!("  -1 as a u8 is : {}", (-1i8) as u8);

  // For positive numbers, this is the same as the modulus
  println!("1000 mod 256 is : {}", 1000 % 256);

  // When casting to a signed type, the (bitwise) result is the same as
  // first casting to the corresponding unsigned type. If the most significant
  // bit of that value is 1, then the value is negative.

  // Unless it already fits, of course.
  println!(" 128 as a i16 is: {}", 128 as i16);

  // In boundary case 128 value in 8-bit two's complement representation is -128
  println!(" 128 as a i8 is : {}", 128 as i8);

  // repeating the example above
  // 1000 as u8 -> 232
  println!("1000 as a u8 is : {}", 1000 as u8);
  // and the value of 232 in 8-bit two's complement representation is -24
  println!(" 232 as a i8 is : {}", 232 as i8);

  // Since rust 1.45, the `as` keyword performs a *saturating cast*
  // when casting from float to int. If the floating point value exceeds
  // the upper bound or is less than the lower bound, the returned value
  // will be equal to the bound crossed.

  // 300.0 as u8 is 255
  println!(" 300.0 as u8 is : {}", 300.0_f32 as u8);
  // -100.0 as u8 is 0
  println!("-100.0 as u8 is : {}", -100.0_f32 as u8);
  // nan as u8 is 0
  println!("   nan as u8 is : {}", f32::NAN as u8);

  // This behavior incurs a small runtime cost and can be avoided
  // with unsafe methods, however the results might overflow and
  // return **unsound values**. Use these methods wisely:
  unsafe {
      // 300.0 as u8 is 44
      println!(" 300.0 as u8 is : {}", 300.0_f32.to_int_unchecked::<u8>());
      // -100.0 as u8 is 156
      println!("-100.0 as u8 is : {}", (-100.0_f32).to_int_unchecked::<u8>());
      // nan as u8 is 0
      println!("   nan as u8 is : {}", f32::NAN.to_int_unchecked::<u8>());
  }
}
```

## ç±»å‹æ¨æ–­

ç±»å‹æ¨æ–­å¼•æ“éå¸¸æ™ºèƒ½ã€‚å®ƒä¸ä»…ä»…åœ¨åˆå§‹åŒ–æœŸé—´æŸ¥çœ‹å€¼è¡¨è¾¾å¼çš„ç±»å‹ã€‚å®ƒè¿˜ç ”ç©¶äº†ä¹‹åå¦‚ä½•ä½¿ç”¨å˜é‡æ¥æ¨æ–­å…¶ç±»å‹ã€‚è¿™æ˜¯ç±»å‹æ¨æ–­çš„é«˜çº§ç¤ºä¾‹ï¼š

```rust
fn main() {
    // Because of the annotation, the compiler knows that `elem` has type u8.
    let elem = 5u8;

    // Create an empty vector (a growable array).
    let mut vec = Vec::new();
    // At this point the compiler doesn't know the exact type of `vec`, it
    // just knows that it's a vector of something (`Vec<_>`).

    // Insert `elem` in the vector.
    vec.push(elem);
    // Aha! Now the compiler knows that `vec` is a vector of `u8`s (`Vec<u8>`)
    // TODO ^ Try commenting out the `vec.push(elem)` line

    println!("{:?}", vec);
}
```

ä¸éœ€è¦å˜é‡çš„ç±»å‹æ³¨é‡Š

## aliasing

type è¯­å¥å¯ç”¨äºä¸ºç°æœ‰ç±»å‹æŒ‡å®šæ–°åç§°ã€‚ç±»å‹å¿…é¡»å…·æœ‰ UpperCamelCase åç§°ï¼Œå¦åˆ™ç¼–è¯‘å™¨å°†å‘å‡ºè­¦å‘Šã€‚æ­¤è§„åˆ™çš„ä¾‹å¤–æ˜¯åŸå§‹ç±»å‹ï¼š usize ã€ f32 ç­‰ã€‚

```rust
// `NanoSecond`, `Inch`, and `U64` are new names for `u64`.
type NanoSecond = u64;
type Inch = u64;
type U64 = u64;

fn main() {
    // `NanoSecond` = `Inch` = `U64` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64;
    let inches: Inch = 2 as U64;

    // Note that type aliases *don't* provide any extra type safety, because
    // aliases are *not* new types
    println!("{} nanoseconds + {} inches = {} unit?",
             nanoseconds,
             inches,
             nanoseconds + inches);
}
```

åˆ«åçš„ä¸»è¦ç”¨é€”æ˜¯å‡å°‘æ ·æ¿ä»£ç ï¼›ä¾‹å¦‚ `io::Result<T>` ç±»å‹æ˜¯ `Result<T, io::Error>` ç±»å‹çš„åˆ«åã€‚

rust é€šè¿‡ä½¿ç”¨ç‰¹å¾æ¥è§£å†³è‡ªå®šä¹‰ç±»å‹ï¼ˆå³ struct å’Œ enum ï¼‰ä¹‹é—´çš„è½¬æ¢ã€‚é€šç”¨è½¬æ¢å°†ä½¿ç”¨ From å’Œ Into ç‰¹å¾ã€‚ç„¶è€Œï¼Œå¯¹äºæ›´å¸¸è§çš„æƒ…å†µï¼Œæœ‰æ›´å…·ä½“çš„æ–¹æ³•ï¼Œç‰¹åˆ«æ˜¯åœ¨ String ä¹‹é—´è¿›è¡Œè½¬æ¢æ—¶ã€‚

## ç±»å‹è½¬æ¢

åŸå§‹ç±»å‹å¯ä»¥é€šè¿‡å¼ºåˆ¶è½¬æ¢ç›¸äº’è½¬æ¢ã€‚

rust é€šè¿‡ä½¿ç”¨ç‰¹å¾æ¥è§£å†³è‡ªå®šä¹‰ç±»å‹ï¼ˆå³ struct å’Œ enum ï¼‰ä¹‹é—´çš„è½¬æ¢ã€‚é€šç”¨è½¬æ¢å°†ä½¿ç”¨ From å’Œ Into ç‰¹å¾ã€‚ç„¶è€Œï¼Œå¯¹äºæ›´å¸¸è§çš„æƒ…å†µï¼Œæœ‰æ›´å…·ä½“çš„æ–¹æ³•ï¼Œç‰¹åˆ«æ˜¯åœ¨ String ä¹‹é—´è¿›è¡Œè½¬æ¢æ—¶ã€‚
### From
From ç‰¹å¾å…è®¸ç±»å‹å®šä¹‰å¦‚ä½•ä»å¦ä¸€ç§ç±»å‹åˆ›å»ºè‡ªèº«ï¼Œä»è€Œæä¾›äº†ä¸€ç§éå¸¸ç®€å•çš„æœºåˆ¶æ¥åœ¨å¤šç§ç±»å‹ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚æ ‡å‡†åº“ä¸­æœ‰è®¸å¤šæ­¤ç‰¹å¾çš„å®ç°ï¼Œç”¨äºåŸå§‹ç±»å‹å’Œå¸¸è§ç±»å‹çš„è½¬æ¢ã€‚

ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥è½»æ¾åœ°å°† str è½¬æ¢ä¸º String

```rust
let my_str = "hello";
let my_string = String::from(my_str);
```
æˆ‘ä»¬å¯ä»¥åšç±»ä¼¼çš„äº‹æƒ…æ¥å®šä¹‰æˆ‘ä»¬è‡ªå·±çš„ç±»å‹çš„è½¬æ¢ã€‚

```rust
use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From<i32> for Number {
    fn from(item: i32) -> Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!("My number is {:?}", num);
}
```

### Into

Into ç‰¹å¾åªæ˜¯ From ç‰¹å¾çš„å€’æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæ‚¨å·²ç»ä¸ºæ‚¨çš„ç±»å‹å®ç°äº† From ç‰¹å¾ï¼Œ Into å°†åœ¨å¿…è¦æ—¶è°ƒç”¨å®ƒã€‚

ä½¿ç”¨ Into ç‰¹å¾é€šå¸¸éœ€è¦æŒ‡å®šè¦è½¬æ¢çš„ç±»å‹ï¼Œå› ä¸ºç¼–è¯‘å™¨å¤§å¤šæ•°æ—¶å€™æ— æ³•ç¡®å®šè¿™ä¸€ç‚¹ã€‚ç„¶è€Œï¼Œè€ƒè™‘åˆ°æˆ‘ä»¬å…è´¹è·å¾—è¯¥åŠŸèƒ½ï¼Œè¿™æ˜¯ä¸€ä¸ªå°å°çš„æƒè¡¡ã€‚

```rust
use std::convert::Into;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl Into<Number> for i32 {
    fn into(self) -> Number {
        Number { value: self }
    }
}

fn main() {
    let int = 5;
    // Try removing the type annotation
    let num: Number = int.into();
    println!("My number is {:?}", num);
}
```

### TryFrom & TryTo

ä¸ From å’Œ Into ç±»ä¼¼ï¼Œ TryFrom å’Œ TryInto æ˜¯ç”¨äºåœ¨ç±»å‹ä¹‹é—´è¿›è¡Œè½¬æ¢çš„é€šç”¨ç‰¹å¾ã€‚ä¸ From / Into ä¸åŒï¼Œ TryFrom / TryInto ç‰¹å¾ç”¨äºæ˜“å‡ºé”™çš„è½¬æ¢ï¼Œå› æ­¤è¿”å› Result

```rust
use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom<i32> for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result<EvenNumber, ()> = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result<EvenNumber, ()> = 5i32.try_into();
    assert_eq!(result, Err(()));
}
```

### toString

å°†ä»»ä½•ç±»å‹è½¬æ¢ä¸º String å°±åƒå®ç°è¯¥ç±»å‹çš„ ToString ç‰¹å¾ä¸€æ ·ç®€å•ã€‚æ‚¨åº”è¯¥å®ç° fmt::Display ç‰¹å¾ï¼Œè€Œä¸æ˜¯ç›´æ¥è¿™æ ·åšï¼Œå®ƒä¼šè‡ªåŠ¨æä¾› ToString ï¼Œå¹¶ä¸”è¿˜å…è®¸æ‰“å° print! éƒ¨åˆ†ä¸­è®¨è®ºçš„ç±»å‹ã€‚

```rust
use std::fmt;

struct Circle {
    radius: i32
}

impl fmt::Display for Circle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Circle of radius {}", self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!("{}", circle.to_string());
}
```

### è§£æå­—ç¬¦ä¸²

å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¤šç§ç±»å‹å¾ˆæœ‰ç”¨ï¼Œä½†æ›´å¸¸è§çš„å­—ç¬¦ä¸²æ“ä½œä¹‹ä¸€æ˜¯å°†å®ƒä»¬ä»å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—ã€‚æƒ¯ç”¨çš„æ–¹æ³•æ˜¯ä½¿ç”¨ parse å‡½æ•°ï¼Œå¹¶å®‰æ’ç±»å‹æ¨æ–­æˆ–ä½¿ç”¨â€œturbofishâ€è¯­æ³•æŒ‡å®šè¦è§£æçš„ç±»å‹ã€‚ä»¥ä¸‹ç¤ºä¾‹æ˜¾ç¤ºäº†ä¸¤ç§æ›¿ä»£æ–¹æ¡ˆã€‚

åªè¦ä¸ºè¯¥ç±»å‹å®ç°äº† FromStr ç‰¹å¾ï¼Œå°±ä¼šå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæŒ‡å®šçš„ç±»å‹ã€‚æ ‡å‡†åº“ä¸­çš„è®¸å¤šç±»å‹éƒ½å®ç°äº†è¿™ä¸€ç‚¹ã€‚è¦åœ¨ç”¨æˆ·å®šä¹‰çš„ç±»å‹ä¸Šè·å¾—æ­¤åŠŸèƒ½ï¼Œåªéœ€å®ç°è¯¥ç±»å‹çš„ FromStr ç‰¹å¾å³å¯ã€‚

```rust
fn main() {
    let parsed: i32 = "5".parse().unwrap();
    let turbo_parsed = "10".parse::<i32>().unwrap();

    let sum = parsed + turbo_parsed;
    println!("Sum: {:?}", sum);
}
```