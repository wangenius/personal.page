---
title : Cache和缓存系统
sidebar_position : 3
slug : Cache和缓存系统
---
# Cache和缓存系统

## Cache

高速缓冲存储器，为了解决CPU和内存之间速度不匹配而采用的一项重要技术。

cache用于CPU与IO争抢内存访问权限，IO的优先级高，CPU直接访问cache不需要等待；由局部性原理，程序的转移概率不会很低，数据分布的离散性大，单纯依靠并行主存系统提高贮存系统的频宽是有限的，使用cache减少访存次数，加快程序执行速度。

Cache局部性原理：时间局部性和空间局部性

cache分为若干大小相等的**块，和主存的块对应**，cache和主存的数据交换以cache块为单位

## 结构

分离cache结构：指令cache和数据cache分开，解决同一cache中资源冒险问题，同时可以充分利用指令和数据的不同局部性来优化性能。

多级cache结构：一般为L1，L2，L3三级。L1离CPU最近。指令和数据Cache的分离一般在L1，通常写分配法和回写法合用，L1对L2是全写法，L2对主存是回写法。

## 映射方式

cache是SRAM，分为若干大小相等的`row`，和主存的`block`对应。cache与CPU之间的数据交换以`word`为单位，cache和主存的数据交换以`row`为单位。通过**地址映射**的方式进行对应。

1. **全相联映射**：`district&cacheBlock(tag)<->inneroffset`，每一块可以装如cache中的任何位置，命中率最高，判断开销最大，时间最长，标记所占额外空间最大。标记比较速度慢，实现成本高，通常需要采用昂贵的按内容寻址的相联存储器

2. **组相联映射**：`district(tag)-group-innerOffset`，组间采用直接映射，组内采用全相联映射。`cacheGroup = memBlock mod cacheGroupTotal`，CPU根据组号位找到对应的cache组，用区位号和标记位进行比较，相等且`status=1`，cache命中。

```rust
有效位-替换计数位-修改位-标记位-cache行号-行（块）内地址
有效位-替换计数位-修改位-标记位（主存块号）-行（块）内地址
有效位-替换计数位-修改位-标记位-组号位-行（块）内地址
```

## 替换算法

1. `RAND`

2. `FIFO`：出现Belady异常

3. 近期最少使用`LRU`：对每个Cache行设置一个计数器，计数规则：未使用一次，数值加1，最大数值淘汰。

4. 最不经常使用算法`LFU`：每访问一次计数位+1，最小数值淘汰

## 写入策略

CPU写请求如果命中，有可能遇到cache和主存内容不一致的问题。所以若cache命中，需要按照一定的写策略处理，常见的方法有全写法和回写法。

1. 全写法`write-through`：同时写入`cache`和主存，配置`write buffer`，增加了访存次数

    2. 非写分配法：cache未命中，只修改主存，不加载到cache

3. 回写法`write-back`：只写入cache，当此块被换出时才写入主存，减少了访存次数，存在不一致隐患。cache每行设置一修改位（脏位），`modified = 1`，需要换出时写入主存。

    4. 写分配法：cache写非命中，将要修改的主存块加载到cache中，然后更新cache

**快表TLB命中一致性**：快表命中，页表一定命中，且该页面一定在内存中，因为TLB命中说明了此页面可以在页表中查询的到，（快表示页表的子集），既然在页表中查询的到，就说明此页面已经调入内存，此页是否在cache中，不能确定，cache和页表是两种独立的机制。

命中率：

