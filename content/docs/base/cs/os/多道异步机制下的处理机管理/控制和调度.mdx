---
title: 控制和调度
sidebar_position: 3
slug: 控制和调度
---

# 控制和调度

## 进程控制

| 动作                 | 内容                                                                                                  | 事件                                                                  |
| -------------------- | ----------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| 创建原语`fork`       | 申请空白PCB-分配资源-初始化PCB-将PCB插入就绪队列                                                      | 用户登录-作业调度-系统提供服务-应用请求                               |
| 撤消原语             | 找到PCB-剥夺CPU-终止子进程-资源归还给父进程或操作系统-删除PCB                                         | 正常结束-异常结束-外界干预                                            |
| 阻塞原语block-P原语  | 找到PCB-保护进程运行现场，暂停进程运行-PCB挂入相应阻塞队列                                            | 等待系统资源-等待合作进程完成工作                                     |
| 唤醒原语wakeup-V原语 | 找到PCB-设置进程为就绪态-将PCB插入就绪队列                                                            | 等待的事情发生                                                        |
| 切换原语             | 将运行环境信息存入PCB-PCB移入相应队列-选择另一个进程执行，并更新其PCB-根据PCB恢复新进程所需的运行环境 | 当前进程时间片到-有更高优先级的进程到达-当前进程主动阻塞-当前进程终止 |

:::success 备注
执行状态到阻塞状态是**主动**调用阻塞原语实现，阻塞状态到就绪状态的唤醒过程是被发现者进程调用唤醒原语的**被动**实现。
:::

> **原语(primitives)**：进程控制用的程序段，执行期间不允许中断，它是一个不可分割的基本单位.  
> 通过关中断指令和开中断指令实现原语的原子性，执行期间不会被中断。(特权指令，只能让内核使用)

## 线程控制

创建线程：调用`pthread_create()`

## 调度

### 类型

调度设计围绕计算机的首要资源CPU的高效利用展开，系统的运行性能在很大程度上取决于调度，调度是多道程序的关健。调度是决定资源分配给哪个进程的行为，是一种决策行为。切换是实际分配的行为，是执行行为。先有资源的调度，才有切换。

|                               类型                               | 说明                                                                                                                                                                                                            |
| :--------------------------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <span style={{display:"inline-block",width:80}}>作业调度</span> | 结果是创建了进程。按照一定原则从外存上处于后备状态的作业选择一个或者多个,分配内存,建立相应的进程，运行频率较低多道批处理系统一般配置了JS，而其他系统通常不需要配置。运行频率较低，通常为几分钟一次。            |
|                             交换调度                             | 实际上是存储器管理的对换功能，将暂时不能运行的进程挂起suspend。**提高内存的利用率和系统的吞吐量**,将处于外存对换区的具备运行条件的进程调入内存,并将其状态修改为就绪态,挂在就绪态上等待.将暂不能运行的进程挂起。 |
|                             进程调度                             | 结果是进程开始执行,进程调度的运行频率很高，一般隔几十毫秒就要运行一次。                                                                                                                                         |


### 进程调度时机

合法调度时机：进程创建、进程结束、进程阻塞、IO中断、系统调用返回

非法调度时机：（需要置系统请求调度标志，在过程结束后进行响应的调度和切换）

中断处理过程中、进程在操作系统内核临界区、原子操作过程中

抢占式调度：遵循优先权，短进程有优先，时间片原则、提高系统吞吐率，响应效率

非抢占调度：分时系统和大多数实时系统，主动放弃处理机，实现简单，系统开销小

调度器本身也是一个程序，目的是为了给执行用户的程序提供资源，包含了一个决定一组程序中谁会赢得CPU时钟周期的算法。非抢占式的调度器中，一个进程要不然就一直执行到底，要不然就自己主动资源放弃处理器，以处理I/O请求，调度器只是安排先后顺序；而抢占式调度器里，调度器从当前进程手中把处理器抢走，交给另一个进程，有这么一个主动的动作。

### 调度算法

|算法|剥夺性|适用|说明|
|-|-|-|-|
|FCFS：先来先服务|非剥夺|作业、进程|效率低，对短作业不利，不利于IO繁忙型作业，利用CPU繁忙型作业|
|SJF：短作业优先|非剥夺、剥夺|作业、进程|对长作业不利，长作业会饥饿，非剥夺不保证紧迫性作业被及时处理，时间是估计的|
|HRRN：高响应比|非剥夺、剥夺|作业|响应比=（作业等待时间+估计运行时间）/ 估计运行时间. 综合了先来先服务和短作业优先的特点：等待时间相同，服务时间越短，响应比越高，SJF，服务时间相同，等待时间越长，响应比越高，FCFS，长作业作业响应比可以随等待时间增加而提高，克服了饥饿现象|
|priority level优先级调度算法|非剥夺、剥夺|作业、进程|静态优先级：系统进程>用户进程，交互进程>非交互进程（前台>后台），IO进程>计算型进程，时长越长优先级越低;动态优先级：优先级会在进程执行过程中动态变化调整。占有CPU时间、等待CPU时间作为参考|
|Round-Robin时间片轮转|剥夺|分时系统进程|时间片的大小确定：系统响应时间：T=N×q q是时间片的大小，N为进程数，进程数一定，时间片和系统响应时间成正比.进程数：系统响应时间一定，进程数和时间片的大小成反比.系统的处理能力|
|Multilevel Feedback Queue Scheduling多级反馈队列调度|剥夺||RR和优先级的综合与发展. 多个就绪队列，各队列的时间片不同，优先级越高，时间片越小，通常是上一级的两倍。每个队列采FCFS|

### 进程上下文切换

操作系统通过上下文切换来实现进程的并发运行。上下文是跟踪进程运行所需的所有状态信息，可能存在于PC、寄存器文件、主存等地方。

用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。所谓的"进程上下文"，可以看作是**用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境**等。(用户不要香菜,多放辣...)

相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文

- 用户级上下文：正文、数据、用户堆栈以及共享存储区
- 寄存器上下文：通用寄存器、指令指针寄存器(EIP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)
- 系统级上下文：进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈

当发生进程调度时，进行进程切换就是上下文切换(context switch)。操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切换

硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的"中断上下文"，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞

切换CPU到另一个进程，需要保存当前进程状态，并恢复另一个进程的状态。上下文是指某一时刻，CPU寄存器和程序计数器的内容。他需要相当可观的CPU时间。有的处理器提供多个寄存器组，这样上下文切换就只需要改变当前寄存器组的指针。模式切换是指用户态和内核态的切换。

进程切换一定会进行上下文切换，产生中断，进行处理器模式切换，从用户态进入内核态再返回用户态；但是处理器模式的切换不一定产生进程的切换，系统调用同样会产生处理器模式的切换，但在逻辑上仍然是同一进程。

程序执行时的一个实例，资源分配的独立单位，拥有独立的地址空间。

多道程序环境下多个程序并发执行。他们失去了封闭性，并具有间接性和不可再现性的特征。为了保证程序在并发执行的过程中实现可再现性和封闭性的要求，引入进程的概念，实现操作系统的并发性和共享性。

为了保证程序在并发执行的过程中实现可再现性和封闭性的要求，引入进程的概念，实现操作系统的并发性和共享性。进程是进程映像的运行过程，进程是能独立运行、独立获得资源（进程是资源分配，拥有资源的基本单位）、独立接受调度（通常使用线程完成）的基本单位。

一个进程实体（进程映像）由PCB、程序段、数据段组成的静态映像。

切换CPU到另一个进程，需要保存当前进程状态，并恢复另一个进程的状态，这个任务称为上下文切换。上下文是指某一时刻，CPU寄存器和程序计数器的内容。他需要相当可观的CPU时间。有的处理器提供多个寄存器组，这样上下文切换就只需要改变当前寄存器组的指针。模式切换是指用户态和内核态的切换。

调度是决定资源分配给哪个进程的行为，是一种决策行为。切换是实际分配的行为，是执行行为。先有资源的调度，才有切换。
