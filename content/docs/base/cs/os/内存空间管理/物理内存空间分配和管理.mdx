---
title: 物理内存空间分配和管理
sidebar_position: 2
slug: 物理内存空间分配和管理
---

# 物理内存空间分配和管理

## 静态分区


| 方式     | 说明                                                                                                                                                                                                |
| :--------: | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <span style={{display:"inline-block",width:80}}>单一连续</span> | 单用户、单任务、静态分配，单道程序、作业结束才能释放内存、内部碎片                                                                                                                                  |
| 固定分区 | 分区大小相等和分区大小不等，但运行时不能改变，程序太大放不进任何分区（需要覆盖技术），内部碎片，不能实现多进程共享一个主存区，静态重定位技术，需要一张分区说明表`PDT:partition description table`。 |

## 动态分区

动态分配内存，空闲分区表`free partition table`或空闲分区链`free partition line`按始地址排序。外部碎片（紧凑技术解决，需要动态重定位寄存器的支持，费时）

### 分配算法

| 名称                    | 说明                                           |
| ----------------------- | ---------------------------------------------- |
| `First Fit`首次适应算法 | （性能最好）地址递增的空闲分区链表从队首来是找 |
| `Next Fit`临近适应算法  | 不是从队首，而是从上此找到的位置               |
| `Best Fit`最佳适应算法  | 容量大小的空闲分区链表从队首来找               |
| `Worst Fit`最坏适应算法 | 容量大小从大到小的空闲分区链表从队首来找       |

### 回收和管理

1. 拼接技术：在分区回收时立即进行拼接或找不到足够的空闲分区时进行拼接
2. 动态重定位分区分配技术：分区分配算法的基础上增加了拼接技术。紧凑技术解决，需要动态重定位寄存器的支持。

## 基本分页

把主存空间分为大小相等且固定的块，块相对较小，作为主存的基本单位，进程也按块划分，执行时，以块为单位逐个申请主存块空间。不会产生外部碎片，只会在最后一个块中可能产生内部碎片

### 概念

| 名称              | 说明                                                                                                                                                               |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| <span style={{display:"inline-block",width:160}}>进程</span>              | page页面、页。页面大小应该是2的整数倍，方便地址交换，一般是`512B ~ 4kB`，逻辑地址结构前部分是页号，从0开始，后部分是页内偏移量。页面的大小由机器的地址结构决定。   |
| 内存              | 块，页框，页帧frame                                                                                                                                                |
| 外存              | 块，盘块block                                                                                                                                                      |
| 逻辑地址结构`LAS` | `logical page(P)<->inpage offset(W)`                                                                                                                               |
| 物理地址结构`PAS` | `physical block(B)<->inblock offset(W)`                                                                                                                            |
| 页表`PT`          | 页块映射表，页表项记录该项页号的实际物理块号，一个进程对应一个页表，记录页面在内存中的物理块号，作用实现页号到物理块号的地址映射，页表项记录该项页号的实际物理块号 |
| 页表寄存器`PTR`   | `PT start address(F)<->PT length(M)`                                                                                                                               |
| 快表`TLB`         | 并行相连存储器                                                                                                                                                     |
| 地址变换机构      | 将逻辑地址转换为内存中的物理地址                                                                                                                                   |

```cpp
if(TLB(P)) return data = m(TLB(P)+W);//快表命中
if(P>M) throw error; //页号大于页表长度，越界中断
ele = m(F + P);//取页表项
data = m(ele);//取数据
```

## 分段

可以反映程序的逻辑结构并有利于段的共享和保护

1. 逻辑地址结构：`segment(S)<->insegment offset(W)`地址空间是二维的，段号和段内偏移必须显式的给出
2. 段表`ST`：段表项记录该段号的段长`L`和在主存的起始地址
3. 段表寄存器`STR`：`segment table start address(F)-ST length(M)`
4. 地址变换机构：将逻辑地址转换为内存中的物理地址

```cpp
if(S > M) throw error; //段号大于段表长度，越界中断
st_ele = m(F+S);//取段表项
if(W > st_ele.L) throw error;//段内偏移 > 段长，越界中断
data = m(st_ele.B + W);//取数据
```

## 段页式

1. 系统中由一个段表寄存器。记录作业的段表始址和段表长度。
2. 进程有一个段表，每个分段有一个页表，不加快表，三次访存。
3. 逻辑地址结构`LAS`：`segment(S)-page(P)-offset(W)`
4. 段表表项：`PT length(C)-PT start address(D)`
5. 页表表项：`block(B)`
6. 段表寄存器`STR`：`ST start address(F)-ST length(M)`

```cpp
if(S > M) throw error;
ele = m(F + S);
if(P > ele.C) throw error;
b = m(ele.D + P);
data = m(b + W);
```

## 请求分页

请求分页原理=基本分页+请求调页功能+页面置换功能。一条指令可以产生多个缺页中断，如取两个操作数的指令。在指令执行期间产生和处理缺页中断，一条指令可以产生多个缺页中断

_页表项_：`page(P)<->block(B)<->status(S)<->access(A)<->modified(M)<->EX address(E)`

```cpp
页表项{
    页号 P;//逻辑页号
    物理块号;//内存块号
    状态位;//是否调入内存
    访问字段 A;//访问次数-置换算法参考
    修改位 M;//是否修改，调换写入内存
    外存地址;//该页在外存上的地址，通常是物理块号
}
```

### 分配策略

1. 多进程：平均分配，按比例分配，优先权分配
2. 单个进程
   1. 固定分配局部替换：每个进程分配的物理块数目是确定的（平均分配，按比例分配，优先权分配）。进程运行期间不会改变。
   2. 可变分配全局替换：OS维护一个`free block queue`，缺页时出队列分配。队列为空时有可能置换所有进程中的任一物理块。
   3. 可变分配局部替换：分配一定量的物理块，当进程频繁缺页时，OS为其分配额外的物理块。

### 调入策略

1. 预调页策略：局部性原理，成功率50%
2. 请求调页策略：一次一页

调入位置：

1. 系统拥有足够的对换区空间
2. 系统没有足够的对换区空间（被修改的部分需要调入对换区，以后需要可以直接从对换区读入，读的速度比写块）

### 置换算法

`Belady`异常（`Belady's Anomaly`）是指在页面置换算法中，增加物理内存的大小可能导致更多的页面错误发生的现象。根据`Belady`的最佳页面置换算法理论，增大物理内存应该能够减少页面错误的次数。然而，在某些情况下，增加物理内存的大小反而导致更多的页面错误，这就被称为`Belady`异常。`Belady`异常的出现并不常见，但它表明了页面置换算法的复杂性和不确定性。

驻留集：给一个进程分配物理页框的集合

工作集（`Working Set`）是指在一段时间内被进程或程序频繁使用的页面集合。工作集通常包含了当前进程或程序的活动数据和指令，以及其周围的一些相关数据。当系统的物理内存无法容纳整个工作集时，就需要进行页面置换，这可能引发抖动问题。

抖动`Thrashing`是指在计算机系统中，当系统的工作集（Working Set）无法完全保存在主存储器中，而需要频繁地进行页面置换时，就会出现抖动。抖动会导致系统花费大量时间在页面置换上，而无法有效执行实际的任务，从而造成性能下降。

1. 最佳`OPT`算法：仅限理论
2. 先进先出`FIFO`：会产生`belady`异常。
3. 最近最久未使用`LRU`：性能较好
4. 时钟置换`CLOCK`：利用访问位

```cpp
if(PT(P).S) PT(P).A=1;//访问存在
while(ptr){
	if(PT(ptr).A == 0) return paging_trans(PT(P).Ex，PT(ptr).B);
	PT(ptr).A = 1;
	++ptr;
}
```

1. CLOCK pro：针对页面修改问题

```cpp
if(PT(P).S) PT(P).A = 1;
noMod00();
mod01();
//重新执行
noMod00();
mod01();

void function noMod00 {
	ptr.loop(1){
		if(PT(ptr).A ==0 && PT(ptr).M == 0) return paging_trans(PT(P).Ex，PT(ptr).B);
		++ptr;
	}
}
void function mod01{
	ptr.loop(1){
		if(PT(ptr).A == 0 && PT(ptr).M == 1) return paging_trans(PT(P).Ex，PT(ptr).B);
		PT(ptr).A == 0;
		++ ptr;
	}
}
```

### 共享保护

1. 地址越界保护
2. 访问控制保护
   1. 上下限寄存器判断是否相同
   2. 重定位寄存器和界地址寄存器，逻辑地址和界地址相比，未发生越界则加上重定位寄存器映射物理地址
3. 内存共享：
   1. 仅限只读区域
   2. 可重入代码（纯代码），允许同时访问不允许修改