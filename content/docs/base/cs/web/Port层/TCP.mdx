---
title: TCP
---

# TCP

运输层向它上面的应用层提供通信服务。面向通信部分的最高层，也是用户功能的最底层。

1. 提供**进程**之间的逻辑通信

2. 传输层对收到的报文进行差错检测（首部和数据部分），网络层只检查IP数据报的首部，不检查数据部分是否出错

3. 复用和分用

4. 

    5. 复用：发送方不同的应用进程都可以使用一个 运输层协议传送数据

    6. 分用：接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的的应用进程。

# UDP

用户数据报协议,**面向报文**的**无连接**、**不可靠服务(尽最大努力交付)**。有差错检验**.没有拥塞控制**，**支持一对一，多对一，一对多，多对多的交互通信**。**首部开销小**。

接收方UDP发现报文目的端口号不正确，不存在对应端口号的应用进程，丢弃该报文，并由ICMP发送端口不可达的差错报文给发送方。`traceroute`


首部：8B，4个字段组成，每个字段都是2B.

伪首部：`UDP checksum`的计算方法和`IP packet checksum`的计算方法相似，但不同的是，`IP packet checksum`只检验`ip packet head`，但`UDP checksum` 则检查包括伪首部、首部和数据部分。

1. 反码计算出16位字的和，将和的反码装进检验和字段发送。

2. 接收方连同伪首部反码计算16位字和，如果全为1，则没有差错。

伪首部第三字段全0，第四字段是IP首部中协议字段的值，UDP协议的该字段是17，第五字段是UDP数据报的长度。

差错校验：

1. UDP检验和的计算方法和IP数据报首部校验和的计算方法相似，但不同的是，IP数据报的校验和只检验IP数据报的首部，但UDP的校验和则检查首部和数据部分。

2. 反码计算出16位字的和，将和的反码装进检验和字段发送

3. 接收方连同伪首部反码计算16位字和，如果全为1，则没有差错。


# TCP

传输控制协议，传输数据之前必须要建立连接，完成后释放。不提供广播和多播服务，由于TCP要提供可靠的、面向连接的服务，因此不可避免的增加了许多开销。面向字节，面向连接，提供可靠交付的虚电路服务。每条连接只能有两个端点，每一条TCP连接只能是**点对点**的。不提供广播和多播服务。提供**可靠交付**服务，无差错，不丢失，不重复，按序到达，因此不可避免的增加了许多开销。**全双工通信**，允许通信双方的应用进程在任何时侯都能发送数据，TCP两端都设有**发送缓存和接收缓存**，用来临时存放双向通信的数据。**面向字节流**，TCP只把应用程序交下来的数据看作是一连串无结构的字节流。TCP不不知道所传送的字节流的含义。一个TCP报文段包含上千个字节是很常见的。

1. 面向连接的运输层协议，每条连接之能有两个端点，每一条TCP连接只能是点对点的

2. 提供可靠交付服务，无差错，不丢失，不重复，按序到达

3. 全双工通信，允许通信双方的应用进程在任何时侯都能发送数据，TCP两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。

4. 面向字节流，TCP中的stream指的是流入到进程或从进程流出的字节序列。TCP只把应用程序交下来的数据看作是一连串无结构的字节流。TCP不不知道所传送的字节流的含义。不保证接收方应用程序收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，但接收到的字节流必须是完全一样的。

5. 一个TCP报文段包含上千个字节是很常见的。

6. TCP虽然是面向字节流的，但是传送的数据单元是报文段segment。

将`datagram`分成多个`segment`，`TCP`管理数据可靠性传输的`PDU`。



1. `Sequence`：保证数据有序，发送本`segment`第一个`bytes`在`data`中的序号

2. `Acknowledgment`：表示到序号`n-1`为止的数据均已正确收到。期望收到对方`next segment`的`data`的`1st bytes`的`sequence`，默认使用*累计确认*。

3. `header length`：`unit = 4b => max(this) = 60B`,`head.fixed = 20B`

4. `URG`：告诉系统有紧急数据，尽快送达。

5. `ACK`：确认报文。

6. `PSH`：接收方*尽快交付*给接收应用进程，不再等整个缓存填满后在向上交付。

7. `RST`：`TCP`连接出错，必须释放连接，*重新建立连接*

8. `SYN`：在连接建立时用来*同步序号*，`SYN=1,ACK=0`,连接请求报文段，对方同意建立连接，响应报文段中使用`SYN=1,ACK=1`。

9. `FIN`：释放连接报文。

10. `window size`：发送报文段的一方的`RWND`，告诉对方从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（字节为单位）。窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着。

11. `check sum`：和`UDP`相同，范围包括首部和数据部分，在计算校验和时，要加`12B`伪首部，伪首部中的协议字段改成`TCP`的`6`.

12. `URG`：指出本`segment`中紧急数据的字节数，紧急指针指出紧急数据末尾在`segment`中的位置，紧急数据结束后就是普通数据。当所有紧急数据都处理完时，`TCP`告诉应用程序恢复到正常操作，即使窗口为`0`也可以发送紧急数据。

13. `option`：长度可变，最长`40B`。最初只有一种选项`MSS`，规定每一个TCP报文段中的数据字段的最大长度。后面还有窗口扩大选项，时间戳选项，选择确认选项。

## 连接管理

TCP的连接：采用C/S方式，主动发起连接建立的进程叫作客户，被动等待连接建立的进程叫作服务器。

1. TCP把连接作为最基本的抽象，TCP的许多特性和TCP是面向连接的这个基本特性有关。TCP连接的端点叫套接字socket或插口。端口号拼接到IP地址构成了套接字

2. 

3. `TCP连接::= {socket1, socket2} = {(IP1:port1), (IP2:port2)}`

### 建立：三次握手

三次握手：`client`和`server`之间交换三个`segment`：`req->ack->ack`

连接准备：首先创建`transmission control block(TCB)`，用来存储`TCP`连接中的一些重要信息。例如`TCP`连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。`server process`是被动等待来自`client process`的请求，因此称为*被动打开连接*。服务进程准备接收客户进程处于LISTEN状态，等待客户的连接请求。

1. 允许双方协商参数（最大窗口值，是否使用窗口扩大选项和时间戳）

2. 对运输实体资源（缓存大小、连接表中的项目）的分配。

3. SYN报文段不能携带数据，但要消耗一个序号

4. 同步确认后为该TCP连接分配缓存和变量

### 废弃：四次挥手

`4way handshake`（交换4个`segment`：C请求，S确认关闭，S请求，C确认关闭）

1. `C`端中断请求，向`TCP`发送`seg(FIN)`。进入`FIN1`的状态。

2. `S`收到`seg(FIN)`发出`seg(ACK)`，进入`close-wait`状态，`C->S`方向的连接释放，`TCP`连接处于半关闭的状态。但S到C的连接并未关闭，`S`要发送数据，`C`仍然要接收。

3. `S`如果发送结束，发送`seg(FIN)`，还需重复上次发送的确认号`{ACK = 1,ack = x + 1}`，S进入`LAST-ACK`。

4. `C`收到`seg(FIN)`后，必须发出`seg(ACK)`，必须经过`2MSL`后，`C`才进入连接关闭状态。



## 滑动窗口协议SWP

### 可靠传输

#### 停等协议SW ARQ

采用单滑动窗口，TCP的滑动窗口是以字节为单位的

重传机制：只有接收窗口向前滑动，发送窗口才能向前滑动（接收到`ACK`）

1. 

    2. 超时重传：超时计时器设置应当比数据在`RTT`更长一些，但这个往返时间无法确定

    3. 快速重传（冗余`ACK`）：以时间为驱动，而是以数据驱动重传，

`(SWND,RWND) = (1,1)`，信道利用率很低，发送方需要对刚发送的数据帧进行缓存副本，在出差错时候进行重传。接收`ACK package`后清除副本。

#### 后退N帧 GBN ARQ

超时重传快速重传累计确认

`(WND,RWND) = (n,1)`


连续发送数据帧提高了信道利用率，但另一方面在重传时又必须把原来已经传送正确的数字帧进行了重传（仅因为这些数字帧的前面由一个数据帧出了错）使得传送效率降低


#### 选择性重传 SR ARQ


接收窗口>1，通常和发送窗口大小相同

接收窗口内来者不拒，只重传错帧


发送周期：从发送方开始发送数据到收到第一个确认帧为止，为一个发送周期，=发送时延+ 往返传播时延

信道效率：一个发送周期内，发送方有效的发送数据所需要的时间占整个发送周期的比值


### 流量控制

确认报文可以进行流量控制，`RWND`减小到`0`时，就不允许发送方再发送数据了。`TCP`为每一个连接设有一个*持续计时器*，`TCP`连接的一方收到对方的零窗口通知，就启用持续计时器，如果持续计数器设置的时间到期，就发送一个零窗口探测报文段，携带`1B`的数据，对方就在确认这个`probe`时给出了现在的窗口值。窗口值仍然是零，那么收到这个报文段的一方就重新设置持续计时器，如果窗口不是零，死锁就被打破了。

应用进程将数据传送到TCP的发送缓存中，剩下发送的任务就交给TCP来控制了。**TCP报文段的发送时机**：

1. MSS，**最大报文段长度**，达到即发送

2. 由发送方应用进程指名要求发送报文段，即**TCP支持的推送PSH操作**

3. 发送方发送**计时器到期**，就把当前缓存数据装入报文段，不能超过MSS

传输层定义的是端到端用户之间的流量控制，数据链路层定义两个中间的相邻结点的流量控制

**数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的则可以动态变化**

### 拥塞控制

不能完全避免`congestion`，拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞：拥塞常常趋于恶化，如果一个路由器没有足够的`cache`，他就会丢弃新到的分组，源点就回重传该分组，甚至还要重传多次。会引起更多的分组流入网络和被网络中的路由器丢弃。

1. 开环控制：静态控制，设计网络时考虑拥塞因素，避免运行拥塞

2. 闭环控制：基于**反馈环路的动态控制**，根据拥塞信息调整网络系统的运行以解决问题。

`SWND.MAX= MIN{RWND,CWND}=>SWND = RWND`

#### 慢开始

网络没有拥塞，`CWND.init = 1`每个`RTT`呈二倍数增加。 只要网络没有出现拥塞，拥塞窗口就可以增大些（二倍数增加），以便把更多的分组发出去，增加网络利用率。

`2CWND`>`ssthresh`时，下一个`RTT`后`CWND = ssthresh`，不能越过。

#### 拥塞避免

1. 当`CWND<ssthresh`，使用慢开始算法

2. 当`CWND>ssthresh`，改用拥塞避免算法，线性增长

拥塞避免不能完全避免拥塞，只能使拥塞窗口控制改为线型增长，使网络不容易出现拥塞

1. `CWND`增加放缓，采用加法增大

2. 只要出现拥塞，就把`ssthresh`减小一半

#### 快重传

以时间为驱动，而是以数据驱动重传，冗余`ACK`，可以让发送方尽早知道发生了个别报文段丢失的情况，当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。

#### 快恢复

快重传出现拥塞，`ssthresh`降为当时`CWND`的一半，`CWND = ssthresh`



**拥塞控制和流量控制的区别：**

1. 拥塞控制防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载，拥塞控制所要左的都有一个前提，就是网络能够承受现在的网络复合，拥塞控制是一个全局性的过程。

2. 流量控制往往是指点对点通信量的控制，是个端到端的问题，流量控制所要做的就是抑制发送端发送数据的速率，以便接收端来得及接收

