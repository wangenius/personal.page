---
title : 语义分析
sidebar_position : 5
slug : 语义分析
---
# 语义分析

语义分析器则是编译器的另一个模块，用于检查源代码的语义是否正确。也称为类型检查、上下文相关分析。它负责检查程序（抽象语法树）的上下文相关的属性，这是具体语言相关的.它会对抽象语法树进行分析，查找源代码中的语法错误和语义错误。语义分析器会对变量、函数、类型等符号进行分析，并生成符号表。同时，它还会进行类型检查，以确保变量、函数和表达式的类型都是正确的。如果发现了错误，语义分析器会生成相应的错误信息。

:::info
`'a' + 'a'` 是符合语法规则、语义规则的
`0 + 'a'` 虽然也符合语法规则，但是不符合语义规则，因为整数与字符串不能相加。
`x += 1`，符合语法规则，但是如果 x 之前没有“定义”过，那么就不能自加 1，不符合语义规则.
:::

语义分析也称为类型检查上下文相关分析负责检查程序抽象语法树的上下文相关的属性比如变量在使用前先进行声明每个表达式都有合适的类型函数调用和函数定义一致对于加运算要求左右操作数都必须是整型数的

类型相等例如对于两个结构体struct a struct B不仅要比较它们是否是结构体还要递归比较结构体中的各个域像Java中两个类class是否有继承关系需要维护错误诊断要给出尽可能准确多的错误信息和准确的出错位置sign代码翻译现在的编译器中的语义分析模块除了做语义分析外还要负责生成中间代码和目标代码语义分析往往是编译器中最庞大也是最复杂的模块

代码生成的任务代码生成负责将源程序翻译成目标机器真实的物理机器或是虚拟机上的代码即将原程序上的数据包括全局局部变量动态分布等分配给计算资源寄存器数据区代码区栈区堆区等给原城区的代码包括表达式运算语句函数等选择合适的机器指令算术运算比较跳转函数调用返回等并实现高层代码的语义

代码生成后的中间代码有哪几种表达方式为什么要划分成不同的中间表示通过代码生成编译器将代码转换为树和有向无环图的AG高层表示适用于程序员程序二三地址码底层表示靠近目标机器三控制流图cfg更为精细的三地址码程序的图状表示适合做程序分析程序优化等四静态担负执行是SSA更精细的控制流图同时编码控制流信息和数据流信息连续传递风格CPS更一般的SSA
编译工作编译器工程上的考虑一阶段划分将整个编译过程划分为不同的阶段二任务分解每个阶段只处理翻译过程的一个步骤三代码工程代码更容易实现出错维护和演进四程序分析和代码优化的需要两者都和程序的中间表示关系密切很多优化在特定的中间表示才可以或才容易进行

三地址码的基本思想是什么给每个中间变量和计算结果命名只有最基础的控制流没有各种控制结构比如if do where for只有go to cold呃故可以看成抽象的指令集和通用的RISC优点是所有操作都是原子的变量没有复合结构控制流结构被简化了只有跳转是抽象的机器代码向后做代码生成更容易缺点是程序的控制流信息是隐式的可以做进一步的控制流分析

到达定义分析和活性分析计算在给定的程序点哪些变量是活跃的活跃信息给出了活跃区间的概念活跃区间互不相交所以三个变量可交替使用一个寄存器

代码优化代码优化是对被优化的程序进行的一种语义保持的变换语义保持是程序的可观察行为不能改变变换的目的是更小更快catch行为更好更节能编译器从业者永不失业定理不存在完全优化不能保证优化总能产生好的结果优化的顺序很关键很多优化问题是非确定的优化的正确性论证数学证明很微妙