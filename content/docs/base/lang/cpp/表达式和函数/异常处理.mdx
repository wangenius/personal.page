---
title: 异常处理
sidebar_position: 12
slug: 异常处理
---

# 异常

在程序设计过程中，我们总是希望自己设计的程序是天衣无缝的，但这几乎又是不可能的。即使程序编译通过，同时也实现了所需要的功能，也并不代表程序就已经完美无缺了，因为运行程序时还可能会遇到异常。

例如，当我们设计一个为用户计算除法的程序时，用户很有可能会将除数输入为零，又例如当我们需要打开一个文件的时候确发现该文件已经被删除了……类似的这种情况很有很多，针对这些特殊的情况，不加以防范是不行的。

我们通常希望自己编写的程序能够在异常的情况下也能作出相应的处理，而不至于程序莫名其妙地中断或者中止运行了。在设计程序时应充分考虑各种异常情况，并加以处理。

在 C++ 中，一个函数能够检测出异常并且将异常返回，这种机制称为抛出异常。当抛出异常后，函数调用者捕获到该异常，并对该异常进行处理，我们称之为异常捕获。

C++ 新增 throw 关键字用于抛出异常，新增 catch 关键字用于捕获异常，新增 try 关键字尝试捕获异常。通常将尝试捕获的语句放在try\{ }程序块中，而将异常处理语句置于catch\{ }语句块中。

## throw

```cpp title="抛出异常的基本语法"
throw 表达式;
```

## try catch

```cpp
try
{
    //可能抛出异常的语句
}
catch (异常类型1)
{
    //异常类型1的处理程序
}
catch (异常类型2)
{
    //异常类型2的处理程序
}
// ……
catch (异常类型n)
{
    //异常类型n的处理程序
}
```

例如:

```cpp title="数组越界的异常捕获程序" showLineNumbers
#include<iostream>
using namespace std;
enum index{underflow, overflow};
int array_index(int *A, int n, int index);
int main()
{
    int *A = new int[10];
    for(int i=0; i<10; i++)
        A[i] = i;
    try
    {
        cout<<array_index(A,10,5)<<endl;
        cout<<array_index(A,10,-1)<<endl;
        cout<<array_index(A,10,15)<<endl;
    }
    catch(index e)
    {
        if(e == underflow)
        {
            cout<<"index underflow!"<<endl;
            exit(-1);
        }
        if(e == overflow)
        {
            cout<<"index overflow!"<<endl;
            exit(-1);
        }
    }
    return 0;
}
int array_index(int *A, int n, int index)
{
    if(index < 0) throw underflow;
    if(index > n-1) throw overflow;
    return A[index];
}
```
:::success assert()
断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>（C）`、`<cassert>（C++）`中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，`include <assert.h> `之前。

使用
```cpp
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>
assert( p != NULL );    // assert 不可用
```
:::