---
title: 错误处理
---

# panic!

panic 可以是被动触发或者主动触发，如果是子线程触发，只会终止触发的那个线程，其他程序不受影响

```rust
fn main() {
    panic!("crash and burn");//panic！宏
}
```

# Result

`Result`枚举用于处理函数返回。在 rust 编程语言中，是一种惯例，如果一个函数可能会失败，那它应该返回 Result 类型而不是直接返回值。

```rust
use std::fs::File;
use std::io;
use std::io::Read;
fn main() {
    _ = read_content();
}
fn read_content() ->Result<String, Box<dyn Error>> { // 注意Result有两个成员Ok,Err,成员可以携带数据，比如这个String就是Ok的
    let mut f = File::open("test.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```

当函数返回值是 Result 时，函数内可以使用宏`?`来快速传播 `Err`

```rust
fn run(config:&Config) -> Result<(), Box<dyn Error>> {
    let content = fs::read_to_string(&config.file_path)?;// 发生错误马上返回
    print!("{},{}",config.query,content);
    Ok(()) // 函数执行正确没有返回值，使用空元组 ()占位
}
```

# unwrap

发生错误，直接 `panic`

`Result`是枚举，要读取里面的数据，需要用 `match`处理，但是也有快速的方法

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap(); // 如果成功，直接返回Ok(T)关联的值，如果失败，直接panic
    let f = File::open("hello.txt").expect("Failed to open hello.txt");// 和unwarp一样，但是会打印自定义panic日志
    let f  = File::open("hello.txt").unwarp_or_else(闭包) // 成功发挥Ok关联的值，失败执行闭包，不会Panic
}
```

# Option

用于处理空值，其他语言一般用 `null`处理空值

```rust
enum Option<T> {
    Some(T),
    None,
}
let maybe_value = Some(42); // 实例化Option实例，绑定一个值
let value = maybe_value.unwrap_or_else(|| 0);// 如果是None就返回0
println!("{}", value);  // Prints 42
```

`unwrap_or_else`处理 `Result`，`Option`，有一个 unwrap_or_else 方法，参数是一个闭包函数，当 Result 是 Err 或者 Option 是 None 时，会调用这个闭包。`Option` 类型应用广泛因为它编码了一个非常普遍的场景，即一个值要么有值要么没值。从类型系统的角度来表达这个概念就意味着编译器需要检查是否处理了所有应该处理的情况，这样就可以避免在其他编程语言中非常常见的 bug。

`Option<T>` 枚举是如此有用以至于它甚至被包含在了 `prelude`之中，你不需要将其显式引入作用域。另外，它的成员也是如此，可以不需要 `Option::` 前缀来直接使用 `Some` 和 `None`。即便如此 `Option<T>` 也仍是常规的枚举，`Some(T)` 和 `None` 仍是 `Option<T>` 的成员。

```rust
let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;//如果使用 `None` 而不是 `Some`，需要告诉 rust `Option<T>` 是什么类型的，因为编译器只通过 `None` 值无法推断出 `Some` 成员保存的值的类型。
```

当有一个 `Some` 值时，我们就知道存在一个值，而这个值保存在 `Some` 中。当有个 `None` 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，`Option<T>` 为什么就比空值要好呢？

简而言之，因为 `Option<T>` 和 `T`（这里 `T` 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 `Option<T>`。例如，这段代码不能编译，因为它尝试将 `Option<i8>` 与 `i8` 相加：

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
/**
error[E0277]: the trait bound `i8: std::ops::Add<std::option::Option<i8>>` is
not satisfied
 -->
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option<i8>`
  |
```

很好！事实上，错误信息意味着 rust 不知道该如何将 `Option<i8>` 与 `i8` 相加，因为它们的类型不同。当在 rust 中拥有一个像 `i8` 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信使用而无需做空值检查。只有当使用 `Option<i8>`（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。

总的来说，为了使用 `Option<T>` 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 `Some(T)` 值时运行，允许这些代码使用其中的 `T`。也希望一些代码在值为 `None` 时运行，这些代码并没有一个可用的 `T` 值。`match` 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。

枚举类型是一个类型，它会包含所有可能的枚举成员，而枚举值是该类型中的具体某个成员，类似 C 的 Union 类型，里面的成员可以是不同的类型。

```rust
enum PokerCard { // 定义枚举类型，里面有4个成员
    Clubs(u8), // 这个成员关联一个u8类型的值
    Spades(u8),
    Diamonds(char), // 这个成员关联一个char类型的值
    Hearts(char),
}
fn main() {
   let c1 = PokerCard::Spades(5); // 实例化一个枚举成员，并且关联5
   let c2 = PokerCard::Diamonds('A');
   print_suit(c1); // 处理枚举变量
   print_suit(c2);
}
fn print_suit(p: PokerCard) { // 传入一个枚举类型的变量
    match p {
        PokerCard::Clubs(value)=> println!("Clubs: {}", value), // 得到枚举成员关联的值
        PokerCard::Spades(value)=> println!("Spades: {}", value),
        PokerCard::Diamonds(value)=> println!("Diamonds: {}", value),
        PokerCard::Hearts(value)=> println!("Hearts: {}", value),
   }
}
```



