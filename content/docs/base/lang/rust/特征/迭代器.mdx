---
title : 迭代器
sidebar_position : 1
slug : 迭代器
---
# 迭代器

Iterator 特征用于实现集合（例如数组）上的迭代器。

该特征仅需要为 next 元素定义一个方法，该方法可以在 impl 块中手动定义或自动定义（如在数组和范围中）。

为了方便应对常见情况， for 构造使用 .into_iter() 方法将某些集合转换为迭代器。
实现了 Iterator trait 的类型，就可以在 rust 中被视为迭代器
```rust
struct Fibonacci {
    curr: u32,
    next: u32,
}

// Implement `Iterator` for `Fibonacci`.
// The `Iterator` trait only requires a method to be defined for the `next` element.
impl Iterator for Fibonacci {
    // We can refer to this type using Self::Item
    type Item = u32;

    // Here, we define the sequence using `.curr` and `.next`.
    // The return type is `Option<T>`:
    //     * When the `Iterator` is finished, `None` is returned.
    //     * Otherwise, the next value is wrapped in `Some` and returned.
    // We use Self::Item in the return type, so we can change
    // the type without having to update the function signatures.
    fn next(&mut self) -> Option<Self::Item> {
        let current = self.curr;

        self.curr = self.next;
        self.next = current + self.next;

        // Since there's no endpoint to a Fibonacci sequence, the `Iterator` 
        // will never return `None`, and `Some` is always returned.
        Some(current)
    }
}

// Returns a Fibonacci sequence generator
fn fibonacci() -> Fibonacci {
    Fibonacci { curr: 0, next: 1 }
}

fn main() {
    // `0..3` is an `Iterator` that generates: 0, 1, and 2.
    let mut sequence = 0..3;

    println!("Four consecutive `next` calls on 0..3");
    println!("> {:?}", sequence.next());
    println!("> {:?}", sequence.next());
    println!("> {:?}", sequence.next());
    println!("> {:?}", sequence.next());

    // `for` works through an `Iterator` until it returns `None`.
    // Each `Some` value is unwrapped and bound to a variable (here, `i`).
    println!("Iterate through 0..3 using `for`");
    for i in 0..3 {
        println!("> {}", i);
    }

    // The `take(n)` method reduces an `Iterator` to its first `n` terms.
    println!("The first four terms of the Fibonacci sequence are: ");
    for i in fibonacci().take(4) {
        println!("> {}", i);
    }

    // The `skip(n)` method shortens an `Iterator` by dropping its first `n` terms.
    println!("The next four terms of the Fibonacci sequence are: ");
    for i in fibonacci().skip(4).take(4) {
        println!("> {}", i);
    }

    let array = [1u32, 3, 3, 7];

    // The `iter` method produces an `Iterator` over an array/slice.
    println!("Iterate the following array {:?}", &array);
    for i in array.iter() {
        println!("> {}", i);
    }
}
```
```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
    // 方法with default implementations elided
}
```

常见的集合类型，例如 Vector、Array、HashSet、HashMap, 字符串 String 类型虽然不是迭代器，但是可以通过.iter() 和 .into_iter() 方法，生成迭代器。

1. into_iter 会夺走所有权

2. iter 是借用

3. iter_mut 是可变借用

```rust
fn main() {
    let arr = vec![1,3,6,8,9,10,11,12,13,14,15];
    let arr_iter = arr.iter(); // 借用
    for v in arr_iter{
        println!("{}", v) // v就是借用每一个元素
    }
}
fn main() {
    let arr = vec![1,3,6,8,9,10,11,12,13,14,15];
    let arr_into_inter = arr.into_iter(); // 元素所有权转移
    for v in arr_into_inter{
        println!("{}", v) //
    }
}
fn main() {
    let arr = vec![1,3,6,8,9,10,11,12,13,14,15];
    let arr_mut_iter = arr.iter_mut(); // 可变借用
         for v in arr_mut_iter{
        *v += 1; // 修改借用元素的值
    }
}
```

###### 消费者适配器

只要迭代器上的某个方法 `A` 在其内部调用了 `next` 方法，那么 `A` 就被称为**消费性适配器**：因为 `next` 方法会消耗掉迭代器上的元素，所以方法 `A` 的调用也会消耗掉迭代器上的元素。

```rust
let arr = vec![1,3,6,8,9,10,11,12,13,14,15];
let arr_ter = arr.iter();
let s:i32 = arr_ter.sum(); // 会把迭代器中的所有元素相加，执行sum后，会转移所有的元素所有权
```

###### 迭代器适配器

迭代器有些方法会返回一个新的迭代器，方便链式调用，结尾一定要有消费者适配器返回数据

```rust
let v1: Vec<i32> = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
```



