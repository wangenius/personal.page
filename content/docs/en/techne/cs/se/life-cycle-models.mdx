---
title: Life-Cycle Models
sidebar_position: 1
slug: lifecycle-models
---

A software life cycle spans three periods—definition, development, and operation/maintenance—each containing multiple stages:

1. **Definition** – Problem definition, feasibility study, requirements analysis (identify needs, build logical models, document results).
2. **Development** – Architecture design, detailed design, coding, testing.
3. **Operation & Maintenance** – Corrective, adaptive, perfective, and preventive maintenance.

<Callout type="success" title="Data Dictionary">
A data dictionary specifies data items, structures, flows, stores, and processing logic. It explains every element in a data-flow diagram, helps impact analysis for change requests, and serves as a foundation for database design.
</Callout>

Different process models emphasize:

- How much work occurs in each phase.
- How often phases repeat.
- When iterations happen.
- How prescriptive the guidance is.

## Waterfall Model

The classic sequential model: requirements → analysis → design → coding → testing → maintenance. Useful for stable requirements but inflexible in practice.

## V-Model

Pairs development stages with corresponding tests: requirements ↔ acceptance tests, architecture ↔ system tests, detailed design ↔ integration tests, implementation ↔ unit tests. Highlights verification and validation at every level.

## Incremental Model

Divides the product into increments (feature slices). Each increment goes through a full mini life cycle—deliver a working subset, gather feedback, then add more functionality. Benefits include earlier value delivery and easier user feedback, but documentation and architectural integrity require discipline.

## Spiral Model

Combines iterative development with explicit risk analysis. Each loop determines objectives and constraints, evaluates and mitigates risks, and then executes a waterfall-style mini-cycle. High risk may even halt the project.

## Fountain Model

Emphasizes overlapping phases and frequent backtracking—akin to water spraying upward and falling back. Teams may re-enter earlier phases (e.g., revisiting requirements during testing), which suits exploratory or object-oriented projects.

<Callout type="success" title="Incremental vs. Iterative">
- **Incremental development** delivers new user-visible functionality in each release; previous increments remain unchanged.
- **Iterative development** revisits the same scope repeatedly to refine quality; each iteration may modify earlier work.
- In practice we often use incremental slices to define what each iteration should deliver.
</Callout>
