---
title: Software Testing
sidebar_position: 3
slug: software-testing
---

## Defect Life Cycle

1. **New** – Tester finds an issue, creates a ticket, and assigns it to the development lead.
2. **Open** – Lead confirms the defect and assigns it to a developer.
3. **Reopen** – Tester retests, still finds the issue, and reopens the ticket.
4. **Rejected** – Lead decides it is not a defect (duplicate, by design, etc.).
5. **Fixed** – Developer implements a fix and returns the ticket for verification.
6. **Closed** – Tester verifies the fix and closes the ticket.

## Testing Workflow

1. Analyze requirements.
2. Plan the tests.
3. Design test cases (ID, title, steps, expected result, input data, priority, prerequisites).
4. Execute tests.
5. Report results.

## Black-Box Testing

Focuses on externally visible behavior without inspecting code. Typical categories: functional, capacity, security, load, recovery, benchmark, stability, reliability.

Common techniques:

- **Equivalence Partitioning** – Divide inputs into classes expected to behave similarly; test one representative per class.
- **Boundary Value Analysis** – Test values at the edges of valid/invalid partitions where defects frequently occur.
- **Decision Tables** – Enumerate combinations of conditions and expected outputs when inputs have logical dependencies.
- **State Transition Testing** – Verify that outputs depend correctly on both current input and previous state.

## White-Box Testing

Examines internal structure and requires knowledge of the code. Techniques include static analysis (control-flow, data-flow, information-flow) and dynamic analysis (statement/branch/path coverage, instrumentation).

Advantages: thorough coverage, ability to reveal hidden errors, forces careful reasoning about implementation. Disadvantages: expensive, may miss missing-path errors, and does not validate the specification itself.

<Callout type="success" title="Black Box vs. White Box">
- **Approach** – Black box tests behavior via inputs/outputs; white box inspects internal logic.
- **Goal** – Black box checks conformance to requirements; white box ensures every execution path behaves as intended.
- **Principles** – Black box adopts the user’s perspective; white box requires covering independent paths and both true/false outcomes for each condition.
</Callout>

## C/S vs. B/S Architectures

| Aspect | Client/Server (C/S) | Browser/Server (B/S) |
| --- | --- | --- |
| Users | Fixed user base on a LAN, homogeneous OS. | Accessible from any OS with a browser. |
| Hardware | Higher client requirements. | Lightweight clients; heavy lifting on servers. |
| Deployment | Software installed/configured on every client; manual upgrades. | No local installation; updates deployed centrally. |
| Security | Strong fine-grained control for trusted users. | Broader attack surface; must harden authentication and transport. |
| Maintenance | Upgrades costly because each client must be touched. | Componentized server-side updates enable seamless releases. |

## SQL Injection Prevention

- Always use parameterized queries / prepared statements.
- Validate and sanitize user inputs.
- Follow least-privilege for database accounts.
- Enable Web Application Firewalls (WAF) and query logging for anomaly detection.
