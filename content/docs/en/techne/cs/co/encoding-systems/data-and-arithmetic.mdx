---
title: Data Representation and Arithmetic
sidebar_position: 1
slug: data-and-arithmetic
---

Programs begin life as **source files**, sequences of bits typically encoded in ASCII/UTF-8. Text files contain only printable characters plus newline (`\n`); everything else is binary. Regardless of format, all information inside a computer is just bits, and context tells us whether a bit pattern represents a character, integer, float, or instruction.

## Fixed-Point Integers

Most CPUs use two’s complement for signed integers because it offers a unique zero, makes subtraction the same as addition, and includes one extra negative value (e.g., −128 for 8-bit numbers). Conversion rules:

- Positive numbers: original, ones’, and two’s complement are identical.
- Negative numbers: two’s complement = bitwise NOT of magnitude + 1. A quick trick is “invert all bits between the most significant 1s.”
- Excess notation (biased representation) flips the sign bit and effectively adds a bias.

Common ranges:

- Unsigned 8/16/32-bit: `0–255`, `0–65535`, `0–4,294,967,295`
- Signed 8/16/32-bit: `−128–127`, `−32,768–32,767`, `−2,147,483,648–2,147,483,647`

### Shifts

- **Logical shift** – Vacated bits filled with 0 (used for unsigned values).
- **Arithmetic shift** – Preserves the sign bit (left shift may overflow if the sign bit changes).

### Addition/Subtraction

Operate on two’s complement numbers. Overflow occurs when adding operands with the same sign yields a result with a different sign, or when the carry into the MSB differs from the carry out.

### Multiplication

Implemented via repeated add-and-shift. For `n`-bit operands, the classic shift-add algorithm performs up to `n` additions and shifts, using ACC (product high half) and MQ (product low half) registers. Booth’s algorithm and other variants reduce the number of additions.

### Division

Restoring/non-restoring division shifts through the dividend `n` times and produces `n+1` quotient bits. Alignment and normalization rules mirror multiplication.

## Floating-Point Numbers

IEEE 754 single precision: `1 sign bit | 8-bit biased exponent | 23-bit fraction (implicit leading 1)`.

- Bias = 127; stored exponent = `E + 127`.
- All-zero exponent → subnormal numbers; all-one exponent → ±∞ or NaN.
- Normalization: left shift mantissa & decrement exponent, or right shift mantissa & increment exponent.

Operations:

1. **Align exponents** (right shift the smaller mantissa).
2. **Add/Subtract mantissas**.
3. **Normalize** (may overflow or underflow exponent).
4. **Round** (can trigger another normalization).

Exponent overflow typically signals ±∞, while underflow results in subnormals or zero.
