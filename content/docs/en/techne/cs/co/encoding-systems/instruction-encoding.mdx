---
title: Instruction Encoding
sidebar_position: 2
slug: instruction-encoding
---

Instruction length depends on opcode size, operand address size, and the number of operands. Typical fields:

- **OP** – Opcode bits (e.g., 8 bits out of a 32-bit instruction register).
- **AD** – Address fields indicating operand locations, result destinations, or the next instruction.

### Address Counts

- **Zero-address instructions** – Stack machines or control instructions (halt, enable/disable interrupts).
- **Fixed-length instruction sets** – Every instruction has the same width (e.g., 32 bits).
- **Variable-length instruction sets** – Different opcodes have different lengths; shorter opcodes are assigned to high-frequency instructions (Huffman-style encoding).

### Addressing Modes

- **Instruction addressing** – Immediate, relative, indirect, etc., determine how the next instruction is located.
- **Data addressing** – Immediate (`#value`), register, direct, indirect, indexed, base+offset, etc. Immediate operands are usually stored in two’s complement form.
- **Implicit operands** – Some instructions assume operands in predefined registers (e.g., accumulator in one-address architectures) to shorten encodings.

### I/O Instructions

I/O opcodes often include a device selector plus a command field describing the action (read, write, status). The opcode distinguishes I/O operations from regular ALU/memory instructions.

### Interrupt “Hidden” Instructions

When an interrupt occurs, hardware automatically performs micro-operations equivalent to an implicit instruction: push PC/flags, disable interrupts (if needed), and jump to the vector. Separate instructions exist to enable (`EINT=1`) or disable (`EINT=0`) maskable interrupts.

### Instruction Set Architecture (ISA)

An ISA abstracts CPU hardware, making it appear to execute one instruction at a time even though micro-architectures pipeline and parallelize work. A **virtual machine** extends the abstraction to include OS and runtime environment.

#### CISC vs. RISC

| Aspect | CISC | RISC |
| --- | --- | --- |
| Instruction count | >200, irregular lengths, many addressing modes, most instructions can access memory | &lt;100, fixed length (often 32 bits), few addressing modes, only load/store instructions access memory |
| Execution time | Highly variable | Most complete in 1 cycle |
| Control | Microprogrammed | Hardwired, deep pipelines |
| Compiler optimization | Difficult | Easier |
| Code size | Typically smaller | Slightly larger |
| Register file | Fewer registers | Many general-purpose registers |

Example micro-operations (accumulator machine):

```
// Non-memory
CLA   0 -> ACC
COM   !ACC -> ACC
SHR   ACC >> 1
CSL   Rotate left
STP   Halt

// Memory access
a ADD   MAR <- Addr(IR); MDR <- M[MAR]; ACC <- ACC + MDR
b STA   MAR <- Addr(IR); M[MAR] <- ACC
c LDA   MAR <- Addr(IR); ACC <- M[MAR]

// Control transfer
JMP   PC <- Addr(IR)
BAN   Branch if ACC negative, etc.
```
