---
title: 语法树
sidebar_position: 4.1
slug: 语法树
---

又叫分析树，是句子结构的图形表示。它代表了句子的推导结果。有利于理解句子语法结构的层次。简单说，语法树就是按照某一规则进行推导时所形成的树。和推导所用的顺序无关（最左，最右或其他）

1. 内部节点代表非终结符
2. 叶子节点都代表终结符
3. 每一步推到代表如何从双亲节点生成它的直接孩子节点。

对句型的推导过程给出一种图形表示，这种图形表示称为语法树，也称推导树。设文法 G=(N，E，S，P)，对 G 的任何句型都能构造与之关联的、满足下列条件的一棵语法树。

每个结点都有一个标记，此标记是 V=N∪E∪ε 中的一个符号。树根的标记是文法的开始符号 S。

若某一结点至少有一个分支结点，则该结点上的标记一定是非终结符。
若 A 的结点有 k 个分支结点，其分支结点的标记分别为 A1,A2,…Ak,则 A→A1A2…Ak 一定是 G 的一条规则

<Callout type="success" title="例子">
根据题目和推导，画出句型 (i+i)\*i-i 的语法树

```
G[E] = ({E,T,F},{i,+,-,*,/,(,)},P,E);
P:
E -> E+T | E-T | T;
T -> T*F | T/F |F;
F → (E) | i;
```

语法树的构造是从文法的开始符号出发，构造一个推导的过程，因为文法的每一个句型(句子)都存在一个推导，所以文法的每个句型(句子)都有一棵对应的语法树。
</Callout>

```text title="最右推导"
E => E - T => E - F => E - i;
=> T - i => T * F - i => T * i - i;
=> F * i - i => (E) * i - i => (E + T) * i - i
=> (E + F) * i - i => (E + i) * i - i
=> (T + i) * i - i => (F + i) * i - i
=> (i + i) * i - i
```

![语法树](/img/语法树.png)

## 二义性

如果一个文法存在某个句子对应两棵不同的语法树，则称这个文法是二义的。也就是说，若一个文法存在某个句子，它有两个不同的最左推导或有两个不同的最右推导，则称这个文法是二义的

二义性的文法将给编译程序的执行带来问题。对于二义性文法的句子，当编译程序对它的结构进行语法分析时，就会产生两种甚至多种不同的理解。语法结构上的不确定性，必将导致语义处理上的不确定性。

解决二义性问题：构造一个等价的无二义性文法；即排除二义性的规则，改写原有的文法。

在改造文法的过程中，观察到推导步骤中的规律：靠前的推导，所用规则结合性弱；语法树上层次高；靠后的推导，所用规则结合性强，语法树上层次低。

也就是说，想要让一个规则结合性弱；就让它出现在推导序列前面（语法树的上层）；想要让一个规则结合性强；就让它出现在推导序列后面（语法树的下层），对于这样的强弱规律正好对应于运算的优先级规律，因此将运算符的优先顺序和结合规则，融合到原有文法中，可构造出无二义性文法

<Callout type="success" title="改造">
对于文法 G[E]：E → E + E | E﹡E | (E) |i

按照终结符优先级的规律，可以构造出无二义性文法 G’[E] 如下：

```
E → E + T | T
T → T * F | F
F → (E) | i
```
</Callout>

## 控制流图

基本块概念

### 自顶向下分析法

### 自底向上分析法

## 抽象语法树
