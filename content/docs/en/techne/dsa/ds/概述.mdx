---
title: Overview
sidebar_position: 1
slug: overview
---

Data structures are containers that store data in specific layouts, making certain operations fast and others slower. Understanding the trade-offs lets us pick the right structure for each problem. Unless noted, examples use C++.

## Terminology

- **Data** – Symbols describing real-world entities.
- **Data element** – Basic unit (record/object instance).
- **Data object** – Set of similar elements (subset of all data).
- **Data item** – Smallest indivisible component of an element.
- **Data structure** – Data objects plus relationships; characterized by logical structure (set/list/tree/graph), storage structure (arrays, linked nodes, hashing), and operations (ADT).

Common operations: insert (`push`, `enqueue`), delete (`pop`, `dequeue`), query (`size`, `find`), update (`set`). Primitive types (ints, floats, chars, booleans) underlie all structures.

## Linear Structures

- **Array** – Contiguous memory, indexed access (O(1)). Basis for many other structures.
- **Linked list** – Nodes connected by pointers (singly/doubly). Efficient inserts/deletes but O(n) access.
- **Stack** – LIFO; supports `push`/`pop` (function call stack, undo history).
- **Queue** – FIFO; supports `enqueue`/`dequeue` (task scheduling, BFS). Variants: circular, deque, priority queue.
- **Hash table** – Uses hash functions to map keys to buckets; average O(1) lookup/insert with collision handling.

## Nonlinear Structures

- **Trees** – Hierarchical nodes with parent/child relations (binary tree, BST, AVL, heap, segment tree, trie). Support order statistics, range queries, priority scheduling.
- **Graphs** – Vertices connected by edges; adjacency lists/matrices. Enable traversal (DFS/BFS), shortest paths, spanning trees.

Choosing a structure depends on required operations, access patterns, and memory layout.
