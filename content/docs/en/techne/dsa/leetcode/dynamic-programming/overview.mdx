---
title: DP Overview
sidebar_position: 1
slug: dp-overview
---

Dynamic Programming = divide problem into overlapping subproblems, remember past results, and build up solution. Steps:

1. **State definition** – Choose variables that uniquely describe a subproblem (e.g., `dp[i]` = ways to reach step `i`).
2. **Base cases** – Explicit answers for smallest states (`dp[0]=1`, `dp[1]=1`).
3. **Transition** – Derive recurrence from optimal substructure (`dp[i] = dp[i-1] + dp[i-2]`).
4. **Order & optimization** – Iterate in dependency order; use rolling arrays to reduce memory when possible.

Typical signs DP applies: need to count/optimize over sequences, subproblems overlap, and greedy/local choices fail. Start with brute-force recursion, add memoization, then convert to bottom-up DP for clarity and efficiency.
