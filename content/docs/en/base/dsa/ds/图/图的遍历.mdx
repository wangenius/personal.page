---
title: Graph Traversal
sidebar_position: 3
slug: traversal
---

## Depth-First Search (DFS)

DFS explores as far as possible along each branch before backtracking. Implementation options:

- **Recursive** – Visit node, mark visited, recurse on unvisited neighbors.
- **Explicit stack** – Simulate recursion when stack depth is an issue.

DFS runs in O(n + m) time with adjacency lists (n vertices, m edges). It produces a DFS tree useful for applications like connected components, SCCs, topological sort, bridge/cut detection.

## Breadth-First Search (BFS)

BFS visits vertices level by level using a queue. Starting from a source, repeatedly pop from the queue, then push all unvisited neighbors. BFS discovers shortest path lengths (edge count) in unweighted graphs.

Pseudocode:

```cpp
vector<int> bfs(int s) {
    queue<int> q;
    vector<int> dist(n, INF);
    q.push(s); dist[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) if (dist[v] == INF) {
            dist[v] = dist[u] + 1;
            q.push(v);
        }
    }
    return dist;
}
```

For disconnected graphs, run DFS/BFS from each unvisited vertex to cover all components.
