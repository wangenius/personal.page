---
title: Shortest Paths
sidebar_position: 4
slug: shortest-path
---

### Dijkstra

Computes single-source shortest paths on graphs with non-negative edge weights.

1. Initialize distance array `dist` (0 for source, ∞ otherwise) and visited set.
2. Repeatedly select the unvisited vertex with smallest `dist`, mark it visited.
3. Relax all outgoing edges from that vertex (update neighbors if shorter path found via this vertex).

Implementation: priority queue (O(m log n)) or adjacency matrix (O(n²)). Cannot handle negative edges.

### Floyd–Warshall

All-pairs shortest paths dynamic programming. Let `dist[i][j]` be initial edge weights (∞ if no edge). For each intermediate vertex `k`, update:

```
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

Runs in O(n³); supports negative edges (but not negative cycles). Path reconstruction uses `next[i][j]` to track intermediates.

**Prim vs. Dijkstra**: Prim builds minimum spanning trees (no specific source, focuses on connecting all vertices). Dijkstra computes shortest paths from one source to all vertices. Both use greedy strategies but solve different problems.
