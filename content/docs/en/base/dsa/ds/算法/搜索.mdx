---
title: Search
sidebar_position: 2
slug: search
---

Brute-force search enumerates the state space to find optimal solutions or count valid ones. Techniques include depth-first search (DFS), breadth-first search (BFS), and bidirectional search. Optimizations involve pruning, ordering, and reducing state space.

### DFS Backtracking

Use recursion to explore choices and backtrack when constraints fail. Example: partition integer `n` into increasing triples:

```cpp
void dfs(int n, int idx, int start) {
    if (n == 0 && idx == 3) { print solution; return; }
    for (int x = start; x <= n; ++x) {
        sol[idx] = x;
        dfs(n - x, idx + 1, x);
    }
}
```

### BFS

Good for shortest path in unweighted graphs or minimal steps problems. Use a queue to explore layer by layer.

### Bidirectional Search

Run BFS/DFS simultaneously from start and goal; stop when frontiers meet. Often reduces search depth from `d` to `d/2`, yielding significant speedups.

Search is foundational for advanced algorithms (DP, backtracking, branch-and-bound). Use it directly for small constraints or as a baseline for partial credit.
