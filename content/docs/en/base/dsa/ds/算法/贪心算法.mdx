---
title: Greedy Algorithms
sidebar_position: 5
slug: greedy
---

Greedy algorithms iteratively make the locally optimal choice, hoping it leads to a global optimum. They typically apply when problems exhibit optimal substructure and greedy-choice property.

Common patterns:

1. **Sort + iterate** – Order tasks by some key (e.g., earliest finish time) and select greedily.
2. **Priority structure** – Maintain a heap/priority queue to repeatedly pick best candidate (e.g., Huffman coding, Prim/Kruskal variants).
3. **Regret technique** – Tentatively accept choices, but replace the worst element if a better candidate appears (e.g., scheduling with penalties).

Proof techniques:

- **Exchange argument** – Show any optimal solution can be transformed into the greedy solution without worsening cost.
- **Induction** – Assume greedy is optimal for smaller inputs and prove extension to larger ones.

Greedy differs from DP: DP explores many subproblems with memoization/backtracking, while greedy never revisits choices. Ensure correctness before applying greedy heuristics.
