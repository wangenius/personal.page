---
title: Dynamic Programming
sidebar_position: 6
slug: dynamic-programming
---

Dynamic programming (DP) solves problems with overlapping subproblems and optimal substructure. Steps:

1. Define state `dp[i]` (or multi-dimensional) capturing partial solutions.
2. Derive recurrence relation using smaller states.
3. Determine base cases.
4. Compute states via iteration or memoized recursion; order must respect dependencies.

Example: climbing stairs (ways to reach step `n` with steps of size 1 or 2).

```
dp[0] = 1, dp[1] = 1
for i from 2..n:
    dp[i] = dp[i-1] + dp[i-2]
```

This matches the Fibonacci sequence. Optimization: keep only two rolling variables to reduce space to O(1).

DP appears in diverse contexts: knapsack, LIS, interval DP, tree DP, digit DP, etc. Key to success is careful state design and transitions.
