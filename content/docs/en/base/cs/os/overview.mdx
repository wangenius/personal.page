---
title: Overview
sidebar_position: 1
slug: overview
---

An operating system (OS) abstracts and manages hardware resources, providing secure and simple interfaces for applications and users. Although hardware and software are logically equivalent, the OS simplifies resource management and enforces protection.

## Why We Need Operating Systems

1. **Safety** – Prevent runaway applications from abusing hardware.
2. **Convenience** – Offer consistent abstractions for controlling complex devices.

OSes virtualize resources:

- **CPU virtualization** – Processes/threads, scheduling, synchronization, IPC.
- **Memory virtualization** – Allocation, protection, address translation, virtual memory.
- **Device virtualization** – Buffering, device drivers, request queues.
- **File systems** – Abstract block devices into files/directories with access control.

Key traits: **concurrency**, **sharing**, **asynchrony**, **virtualization**. Concurrency enables multiple tasks; sharing requires synchronization; asynchrony arises because tasks proceed independently; virtualization provides each task with logical resources.

## Interfaces

- **Command interfaces** – GUIs, CLIs, batch scripts.
- **Program interfaces (system calls)** – Functions exposed by the kernel so applications can request services (allocate memory, access devices, etc.). User-space pointers refer to virtual addresses managed by the kernel.

## Virtual Machines

A Virtual Machine Monitor (VMM)/hypervisor virtualizes hardware for guest OSes:

1. **Bare-metal (Type 1)** – Runs directly on hardware, schedules physical resources for guests, offers high performance and density but limited portability.
2. **Hosted (Type 2)** – Runs atop a host OS, translating guest requests into host system calls; easier to deploy but with more overhead.
