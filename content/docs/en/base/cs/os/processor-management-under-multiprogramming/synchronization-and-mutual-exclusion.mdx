---
title: Synchronization and Mutual Exclusion
sidebar_position: 2
slug: synchronization
---

Mutual exclusion prevents concurrent access to critical sections (shared data), while synchronization coordinates the order of dependent operations. Most synchronization mechanisms build on mutual exclusion.

## Mutual Exclusion Techniques

- **Peterson’s algorithm** – Software-only solution using flags and a `turn` variable (two threads).
- **Disable interrupts** – Only suitable inside the kernel and on uniprocessors.
- **Atomic instructions** – `test-and-set`, `compare-and-swap`, etc., used to build spin locks or mutexes.
- **Mutexes/semaphores** – OS-provided primitives that block threads rather than spinning when contention occurs.

Requirements: mutual exclusion, progress (no deadlock), and bounded waiting.

## Synchronization Primitives

### Semaphores

```c
wait(S)  { while (S <= 0) ; S--; }
signal(S){ S++; }
```

Counting semaphores track available units of a resource; binary semaphores behave like mutexes. The blocking version associates a queue so that `wait` causes the caller to sleep when `S < 0`, and `signal` wakes one waiting thread.

### Monitors

A monitor encapsulates shared state, exposes procedures, and ensures only one thread executes inside at a time. Condition variables (`wait`, `signal`) allow threads to block until a condition becomes true.

```c
monitor Buffer {
    int count = 0;
    condition not_full, not_empty;

    void put(item x) {
        if (count == N) not_full.wait();
        // insert x
        count++;
        not_empty.signal();
    }

    item get() {
        if (count == 0) not_empty.wait();
        count--;
        not_full.signal();
        return item;
    }
}
```

Monitors enforce mutual exclusion automatically and use condition variables to implement synchronization relationships (producer-consumer, readers-writers, etc.).
