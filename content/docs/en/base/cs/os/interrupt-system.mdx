---
title: Interrupt System
sidebar_position: 3
slug: interrupts
---

Interrupts are the mechanism by which the OS regains control of the CPU. Without interrupts there would be no preemption and no true concurrency.

## Types

- **Exceptions (synchronous/internal)** – Generated by the current instruction.
  - *Traps* – Deliberate (system calls) and return to the next instruction.
  - *Faults* – Correctable conditions (e.g., page faults); after handling, the faulting instruction is retried.
  - *Aborts* – Fatal errors; control does not return to the offending task.
- **Interrupts (asynchronous/external)** – Generated by devices or timers (clock interrupts, I/O completion). The next-instruction address is saved as the return point.

## Components

| Component | Description |
| --- | --- |
| Interrupt source | Device raising the request. |
| Interrupt request line (`INTR`, `NMI`) | Signals pending interrupts (maskable vs. non-maskable). |
| Mask register (`MASK`) | Per-source enable/disable bits. |
| Interrupt vector | Entry address of the handler for that source. |
| Vector table | Array mapping vector numbers to handler addresses. |

## Priorities

- **Response priority** – The hardware-defined order in which simultaneous requests are acknowledged (without masking).
- **Processing priority** – The actual order after applying mask bits (software-controlled).

## Handling Flow

1. Device sets its request line (`INTR = 1`).
2. CPU finishes the current instruction, checks `EINT`, and acknowledges the highest-priority pending request.
3. Hardware automatically:
   - Disables further maskable interrupts (optional).
   - Saves the return address/program state.
   - Loads the vector address into `PC`.
4. Handler executes: save registers, optionally re-enable interrupts (for nesting), service the device, restore registers.
5. Issue `iret`/`reti` to resume the interrupted task.

Nested interrupts are allowed when a handler re-enables interrupts and the new request has higher priority.
