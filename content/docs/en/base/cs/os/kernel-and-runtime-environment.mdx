---
title: Kernel and Runtime Environment
sidebar_position: 2
slug: kernel-and-runtime
---

Think of the OS as a restaurant: user mode is the dining area, kernel mode is the kitchen. Customers (applications) request services via waitstaff (system calls). Only trusted chefs (kernel code) may handle dangerous equipment.

## Kernel Responsibilities

- Provide system call interfaces.
- Schedule and synchronize processes/threads.
- Manage physical and virtual memory (paging, swapping).
- Implement file systems and I/O paths.
- Drive hardware via device drivers.
- Handle clocks, interrupts, atomic primitives, and data structures (PCB, DCB, queues, etc.).

Not every library function triggers a system call; many operations (string handling, math, data structures) happen entirely in user space unless they need kernel services.

## Kernel Architectures

1. **Layered** – Clear separation between layers; easier to reason about but may incur overhead.
2. **Modular** – Components with well-defined interfaces, often loadable at runtime (e.g., drivers).
3. **Monolithic** – Bulk of functionality in kernel space; fast but harder to maintain.
4. **Microkernel** – Minimal kernel (IPC, scheduling, memory), services run in user space; more reliable but more context switches.
5. **Exokernel** – Exposes hardware resources directly to applications for maximum flexibility.

## Mode Transitions

The CPU boots in kernel mode and later yields to user mode. User → kernel transitions occur via:

1. **System calls** – User explicitly requests a privileged service (trap instruction).
2. **Exceptions** – Faults such as divide-by-zero or page faults force the CPU into kernel mode.
3. **Interrupts** – Devices signal completion or events, causing the kernel to run an interrupt handler.

Kernel → user transitions occur via `iret`/`sysret` (interrupt return) after the kernel saves/restores context.
