---
title : impl trait

slug : impl trait
---

impl Trait 可以在两个位置使用：

作为参数类型
作为返回类型

## 作为参数类型
如果您的函数在特征上是通用的，但您不介意特定类型，则可以使用 impl Trait 作为参数类型来简化函数声明。

例如，考虑以下代码：

```rust
fn parse_csv_document<R: std::io::BufRead>(src: R) -> std::io::Result<Vec<Vec<String>>> {
    src.lines()
        .map(|line| {
            // For each line in the source
            line.map(|line| {
                // If the line was read successfully, process it, if not, return the error
                line.split(',') // Split the line separated by commas
                    .map(|entry| String::from(entry.trim())) // Remove leading and trailing whitespace
                    .collect() // Collect all strings in a row into a Vec<String>
            })
        })
        .collect() // Collect all lines into a Vec<Vec<String>>
}
```

parse_csv_document 是通用的，允许它采用任何实现 BufRead 的类型，例如 `BufReader<File>` 或 [u8] ，但什么类型 R 是，而 R 仅用于声明 src 的类型，因此该函数也可以写为：

```rust
fn parse_csv_document(src: impl std::io::BufRead) -> std::io::Result<Vec<Vec<String>>> {
    src.lines()
        .map(|line| {
            // For each line in the source
            line.map(|line| {
                // If the line was read successfully, process it, if not, return the error
                line.split(',') // Split the line separated by commas
                    .map(|entry| String::from(entry.trim())) // Remove leading and trailing whitespace
                    .collect() // Collect all strings in a row into a Vec<String>
            })
        })
        .collect() // Collect all lines into a Vec<Vec<String>>
}
```

请注意，使用 impl Trait 作为参数类型意味着您无法明确说明您使用的函数形式，即 `parse_csv_document::<std::io::Empty>(std::io::empty())` 不适用于第二个示例。

## 作为返回类型
如果您的函数返回实现 MyTrait 的类型，则可以将其返回类型编写为 -> impl MyTrait 。这可以帮助大大简化您的类型签名！

```rust
use std::iter;
use std::vec::IntoIter;

// This function combines two `Vec<i32>` and returns an iterator over it.
// Look how complicated its return type is!
fn combine_vecs_explicit_return_type(
    v: Vec<i32>,
    u: Vec<i32>,
) -> iter::Cycle<iter::Chain<IntoIter<i32>, IntoIter<i32>>> {
    v.into_iter().chain(u.into_iter()).cycle()
}

// This is the exact same function, but its return type uses `impl Trait`.
// Look how much simpler it is!
fn combine_vecs(
    v: Vec<i32>,
    u: Vec<i32>,
) -> impl Iterator<Item=i32> {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!("all done");
}
```

更重要的是，有些 rust 类型无法写出。例如，每个闭包都有自己的未命名具体类型。在 impl Trait 语法之前，您必须在堆上分配才能返回闭包。但现在你可以静态地完成这一切，如下所示：

```rust
// Returns a function that adds `y` to its input
fn make_adder_function(y: i32) -> impl Fn(i32) -> i32 {
    let closure = move |x: i32| { x + y };
    closure
}

fn main() {
    let plus_one = make_adder_function(1);
    assert_eq!(plus_one(2), 3);
}
```
您还可以使用 impl Trait 返回使用 map 或 filter 闭包的迭代器！这使得 map 和 filter 的使用更加容易。由于闭包类型没有名称，因此如果函数返回带闭包的迭代器，则无法写出显式返回类型。但使用 impl Trait 你可以轻松做到这一点：

```rust
fn double_positives<'a>(numbers: &'a Vec<i32>) -> impl Iterator<Item = i32> + 'a {
    numbers
        .iter()
        .filter(|x| x > &&0)
        .map(|x| x * 2)
}

fn main() {
    let singles = vec![-3, -2, 2, 3];
    let doubles = double_positives(&singles);
    assert_eq!(doubles.collect::<Vec<i32>>(), vec![4, 6]);
}
```
