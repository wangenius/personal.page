---
title: 编排层设计哲学
---

这是整个白皮书里最容易被忽视、但对真实 Agent 系统最关键的一节。

我会重点解释：

- Orchestration 为什么是“智能的来源，而不是模型”
- Persona、Domain Prompt、Context、Memory 这些词在工程上到底意味着什么
- 如何设计一个可控、可扩展、可解释、可维护的 Orchestration 层
- 为什么 Orchestration 才是未来 Agent 系统的护城河

## Orchestration Layer Design Choices

（编排层的设计哲学：角色、领域知识、上下文、记忆）

白皮书的观点非常强烈：

> “Orchestration is where the intelligence actually lives.”
> ——智能不是在模型里，而是在“你如何组织模型”的方式里。

Orchestration 是 Agent 的“皮层系统”，负责：

- 谁说话
- 什么时候说
- 用哪些信息说
- 说完之后做什么
- 遇到错误怎么办
- 什么时候停
- 什么时候换策略
- 如何切换角色
- 如何使用工具

模型只是被调用的推理引擎，
Orchestration 才是整个系统的行为控制器。

## 6.1 Persona（角色模型）

（定义“你希望这个 Agent 成为什么样的人”）

Persona 不是“写一个花里胡哨的提示词”，而是一种 行为约束系统。

白皮书指出：

> Persona 是 Agent 的「行为边界」「决策框架」「态度」「风格」和「能力范围」的集合。

工程级 Persona 包含：

## 6.1.1 行为范围（Scope of Responsibility）

Persona 不是：

- 你很聪明
- 你很严谨
- 你很专业

而是：

- 你负责任务的哪一段？
- 你能决定哪些事？
- 哪些事你必须升级给别的 Agent？
- 哪些事你没有权限？

例如：

- “你负责规划，但不能执行工具”
- “你能写代码，但不能写数据库”
- “你能总结，但不能决策”

Persona 本质是角色边界控制（boundary control）。

## 6.1.2 决策偏好（Decision Style）

Persona 决定 Agent 如何做选择：

- 保守 / 激进
- 求稳 / 求快
- 成本敏感 / 准确性敏感
- 质量优先 / 效率优先

Persona 是 Agent 的“系统性偏好函数”。

## 6.1.3 语气风格（Voice & Tone）

这是最浅层，但也重要：

- 简明
- 严肃
- 技术性
- 友好
- 判断型
- 推荐型

Persona 必须持续一致，不是随意漂移。

## 6.1.4 Persona = 行为差异化

白皮书强调：

> 角色化（Personas）可以让同模型表现出截然不同的行为模式。

例如同一个 LLM，可在：

- Planner Persona 下像项目经理
- Research Persona 下像情报分析
- Critic Persona 下像审计官
- Executor Persona 下像调度引擎

这就是“角色驱动的智能分形”。

## 6.2 Domain Knowledge（领域知识）

（告诉 Agent：这里的世界是怎么运行的）

白皮书强调：

> “Domain knowledge is foundational. Without it, the agent hallucinates structure that does not exist.”
> ——没有领域约束，Agent 会“妄想出不存在的世界结构”。

## 6.2.1 领域知识的四类内容

### (1) 规则（Rules）

- 业务规则
- 合规要求
- 逻辑约束
- 权限模型

### (2) 术语（Terminology）

定义系统实体：

- Ticket
- User
- Order
- Agent
- Tool
- Workflow

### 数据结构（Schemas）

任务输入/输出的结构：

```text
- Order = {id, status, created_at, ...}
- Query = {filters, sort, max_results}
```

### 策略（Policies）

- 客户优先级策略
- 重试策略
- 错误分类策略
- 成本预算策略

这些内容必须：

- 持久化
- 可读取
- 可检索
- 可版本化

不能写死在 Prompt 里，那会让系统变成黑箱。

---

# 6.3 Context Engineering（上下文工程）

（Agent 能否“保持聪明”，取决于它如何构建上下文）

白皮书观点：

> “Context is the primary substrate the agent reasons over.”
> ——上下文，是 Agent 的思维土壤。

上下文工程 ≠ 拼 prompt
而是 信息选择、组织、剪裁、压缩、编码、排序 的系统设计。

## 什么叫“正确的上下文”？

正确上下文包含：

- 当前任务
- 任务目标
- 最近几轮行动/观察
- 工具结果
- 领域知识
- Persona
- 已知事实
- 外部数据
- 避免的错误
- 优先级

上下文必须：

- 全
- 准
- 短
- 结构化
- 低噪声

过多 → 模型迷失
过少 → 模型报错
顺序不对 → 模型误判
格式混乱 → 模型解码失败

---

# 6.4 Memory（记忆系统）

（Agent 之所以是“Agent”，是因为它能跨回合保持状态）

白皮书明确说：

> “Memory is a first-class component of agentic design.”
> ——记忆是智能体设计的一级概念。

它不是一个向量库，而是一个 多级结构：

---

## Memory 的四个层次

### (1) 短期记忆（Short-term memory）

存当前任务的：

- 最近几轮
- Action + Observation
- 临时变量

用于下一轮推理。

### (2) 中期记忆（Task-level memory）

整个 Mission 的轨迹：

- 子任务列表
- 工具调用历史
- 失败/成功模式
- 中间结果

用于任务复盘与修正。

### (3) 长期记忆（Long-term memory）

跨任务：

- 用户偏好
- 行为模式
- 风险点
- 常见失败模式
- 历史任务经验

用于自我优化的基础。

### (4) 稳定知识库（Knowledge Base / RAG）

- 文档
- 领域知识
- 工具规范
- 规则体系
- 公司策略
- 历史案例

用于给模型提供“静态长期事实”。

---

## 记忆的关键不是储存，而是“选择”

一个 Memory 系统至少要做三件事：

1. 决定何时写入
2. 决定是否写入
3. 决定哪些要取出来提供给模型

这三件事，决定 Memory 是否“真正有用”。

---

# 为什么 Orchestration 才是未来的核心？

白皮书的观点非常清晰：

> “The orchestration layer is the true architecture of an agentic system.”
> ——编排层才是真正决定智能体架构的部分。

原因：

### 1. 模型会被不断替换，但 Orchestration 不会。

### 2. Tools 和 Memory 都是 Orchestrator 管的。

### 3. Task Loop 完全由 Orchestrator 控制。

### 4. 多 Agent 协作完全依赖 Orchestrator 的调度。

### 5. 安全和权限是 Orchestrator 的责任。

### 6. 评估、监控、可观测性也在 Orchestrator。

换句话说：

> LLM 是“可插拔的引擎”，
> Orchestrator 才是“系统的灵魂”。

哪些公司未来能成为 Agent 时代的基础设施？
不是模型公司，而是：

- 能控制 Orchestration 的公司
- 能形成 Tool 生态的公司
- 能构建 Memory/Policy 层的公司
- 能形成 Multi-Agent runtime 的公司

---

# Part 6 总结：架构级洞察

如果这一节只留下三句话：

### 1. Orchestration = Intelligence

智能体的“智慧”来自 orchestrator，而不是模型权重。

### 2. Persona × Domain Knowledge × Context × Memory = 行为结构

这是决定 Agent 行为的四大抽象层。

### 3. Agent 的难点不是推理，而是“信息与行为的管理系统”
